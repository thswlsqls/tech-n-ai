# 에러 핸들링 전략 설계서

**작성 일시**: 2026-01-07  
**대상**: API 에러 핸들링 전략  
**아키텍처**: RESTful API

## 목차

1. [개요](#개요)
2. [HTTP 상태 코드와 비즈니스 에러 코드 분리](#http-상태-코드와-비즈니스-에러-코드-분리)
3. [에러 코드 체계](#에러-코드-체계)
4. [에러 응답 형식](#에러-응답-형식)
5. [에러 처리 전략](#에러-처리-전략)
6. [예외 처리 흐름](#예외-처리-흐름)

---

## 개요

이 설계서는 HTTP 상태 코드와 비즈니스 에러 코드를 분리하여 상세한 에러 정보를 제공하는 전략을 다룹니다. 클라이언트가 HTTP 상태 코드만으로는 파악하기 어려운 비즈니스 로직 에러를 명확히 구분할 수 있도록 합니다.

### 설계 원칙

1. **HTTP 상태 코드와 비즈니스 에러 코드 분리**: HTTP 프로토콜 레벨과 애플리케이션 레벨 에러를 명확히 구분
2. **일관된 에러 응답 형식**: 모든 에러 응답이 동일한 구조를 따름
3. **상세한 에러 정보 제공**: 클라이언트가 에러를 처리할 수 있도록 충분한 정보 제공
4. **국제화 지원**: 에러 메시지 코드를 통한 다국어 지원

---

## HTTP 상태 코드와 비즈니스 에러 코드 분리

### 분리 원칙

HTTP 상태 코드는 HTTP 프로토콜 레벨의 상태를 나타내고, 비즈니스 에러 코드는 애플리케이션 레벨의 상세 에러를 나타냅니다.

- **HTTP 상태 코드**: HTTP 프로토콜 레벨의 상태 (200, 400, 401, 403, 404, 500 등)
- **비즈니스 에러 코드**: 애플리케이션 레벨의 상세 에러 코드 (응답 body의 `code` 필드)

### HTTP 상태 코드 매핑

| HTTP 상태 코드 | 의미 | 비즈니스 에러 코드 예시 | 사용 시나리오 |
|---------------|------|----------------------|--------------|
| 200 OK | 성공 | 2000 | 정상 처리 완료 |
| 400 Bad Request | 잘못된 요청 | 4000 | 요청 파라미터 오류, 유효성 검증 실패 |
| 401 Unauthorized | 인증 실패 | 4001 | JWT 토큰 없음, 토큰 만료, 토큰 검증 실패 |
| 403 Forbidden | 권한 없음 | 4003 | 권한 부족, 접근 거부 |
| 404 Not Found | 리소스 없음 | 4004 | 존재하지 않는 리소스 조회 |
| 429 Too Many Requests | Rate limit 초과 | 4029 | API 호출 한도 초과 |
| 500 Internal Server Error | 서버 오류 | 5000 | 내부 서버 오류, 예상치 못한 예외 |
| 503 Service Unavailable | 서비스 불가 | 5003 | 외부 API 장애, 데이터베이스 연결 실패 |

### 분리 장점

1. **명확한 에러 구분**: HTTP 프로토콜 레벨과 애플리케이션 레벨 에러를 명확히 구분
2. **상세한 에러 정보**: 비즈니스 에러 코드로 구체적인 에러 원인 파악 가능
3. **클라이언트 처리 용이**: 클라이언트가 비즈니스 에러 코드로 적절한 처리 가능
4. **확장성**: 새로운 비즈니스 에러 코드 추가가 용이

---

## 에러 코드 체계

### 에러 코드 구조

에러 코드는 4자리 숫자로 구성되며, 첫 번째 자리 숫자로 에러 범주를 구분합니다:

- **2xxx**: 성공
- **4xxx**: 클라이언트 에러
- **5xxx**: 서버 에러

### 성공 코드 (2xxx)

| 코드 | 메시지 코드 | 설명 |
|------|------------|------|
| 2000 | SUCCESS | 일반 성공 |

### 클라이언트 에러 코드 (4xxx)

| 코드 | 메시지 코드 | HTTP 상태 코드 | 설명 |
|------|------------|----------------|------|
| 4000 | BAD_REQUEST | 400 | 잘못된 요청 (요청 파라미터 오류, 유효성 검증 실패) |
| 4001 | AUTH_FAILED | 401 | 인증 실패 (JWT 토큰 없음, 토큰 만료, 토큰 검증 실패) |
| 4002 | AUTH_REQUIRED | 401 | 인증 필요 (로그인 필요) |
| 4003 | FORBIDDEN | 403 | 권한 없음 (접근 권한 부족) |
| 4004 | NOT_FOUND | 404 | 리소스 없음 (존재하지 않는 리소스) |
| 4005 | CONFLICT | 409 | 충돌 (중복 데이터, 동시성 충돌) |
| 4006 | VALIDATION_ERROR | 400 | 유효성 검증 실패 (필드별 상세 에러 정보 포함) |
| 4029 | RATE_LIMIT_EXCEEDED | 429 | Rate limit 초과 (API 호출 한도 초과) |

### 서버 에러 코드 (5xxx)

| 코드 | 메시지 코드 | HTTP 상태 코드 | 설명 |
|------|------------|----------------|------|
| 5000 | INTERNAL_SERVER_ERROR | 500 | 내부 서버 오류 (예상치 못한 예외) |
| 5001 | DATABASE_ERROR | 500 | 데이터베이스 오류 (연결 실패, 쿼리 오류) |
| 5002 | EXTERNAL_API_ERROR | 502 | 외부 API 오류 (외부 API 호출 실패) |
| 5003 | SERVICE_UNAVAILABLE | 503 | 서비스 불가 (외부 API 장애, 데이터베이스 연결 실패) |
| 5004 | TIMEOUT | 504 | 타임아웃 (요청 처리 시간 초과) |

### 확장 가능한 에러 코드

향후 새로운 에러 코드가 필요한 경우, 다음 규칙을 따릅니다:

- **4xxx**: 클라이언트 에러 (4000-4999)
- **5xxx**: 서버 에러 (5000-5999)

---

## 에러 응답 형식

### 기본 구조

모든 에러 응답은 다음 구조를 따릅니다:

```json
{
  "code": "4000",
  "messageCode": {
    "code": "BAD_REQUEST",
    "text": "잘못된 요청입니다."
  }
}
```

### 필드 설명

| 필드명 | 타입 | 필수 | 설명 |
|--------|------|------|------|
| code | String | 필수 | 에러 코드 (예: "4000", "4001", "5000" 등) |
| messageCode | Object | 필수 | 에러 메시지 코드 객체 |
| messageCode.code | String | 필수 | 에러 메시지 코드 |
| messageCode.text | String | 필수 | 에러 메시지 텍스트 (국제화 지원) |

**주의**: 에러 응답에는 `message` 필드와 `data` 필드가 없습니다.

### 유효성 검증 에러 응답

유효성 검증 실패 시 필드별 상세 에러 정보를 포함할 수 있습니다:

```json
{
  "code": "4006",
  "messageCode": {
    "code": "VALIDATION_ERROR",
    "text": "유효성 검증에 실패했습니다."
  },
  "errors": [
    {
      "field": "email",
      "code": "EMAIL_INVALID",
      "message": "이메일 형식이 올바르지 않습니다."
    },
    {
      "field": "password",
      "code": "PASSWORD_TOO_SHORT",
      "message": "비밀번호는 최소 8자 이상이어야 합니다."
    }
  ]
}
```

### 필드 설명 (유효성 검증 에러)

| 필드명 | 타입 | 필수 | 설명 |
|--------|------|------|------|
| errors | Array | 선택 | 필드별 상세 에러 정보 배열 |
| errors[].field | String | 필수 | 에러가 발생한 필드명 |
| errors[].code | String | 필수 | 필드별 에러 코드 |
| errors[].message | String | 필수 | 필드별 에러 메시지 |

---

## 에러 처리 전략

### 예외 계층 구조

예외는 다음 계층 구조로 처리합니다:

1. **비즈니스 예외**: 애플리케이션 레벨 예외 (예: 리소스 없음, 권한 없음)
2. **시스템 예외**: 시스템 레벨 예외 (예: 데이터베이스 오류, 외부 API 오류)
3. **예상치 못한 예외**: 처리되지 않은 예외 (예: NullPointerException, IllegalArgumentException)

### 예외 처리 흐름

```
요청 → 컨트롤러 → 서비스 → 리포지토리
                          ↓
                    예외 발생
                          ↓
              예외 타입에 따라 분기
                          ↓
        ┌─────────────────┼─────────────────┐
        ↓                 ↓                 ↓
   비즈니스 예외    시스템 예외    예상치 못한 예외
        ↓                 ↓                 ↓
   4xxx 에러 코드    5xxx 에러 코드    5000 에러 코드
        ↓                 ↓                 ↓
              GlobalExceptionHandler
                          ↓
                    에러 응답 반환
```

### 예외 처리 규칙

1. **비즈니스 예외**: 
   - 적절한 4xxx 에러 코드 반환
   - 클라이언트가 처리할 수 있는 에러 정보 제공

2. **시스템 예외**:
   - 적절한 5xxx 에러 코드 반환
   - 상세한 에러 정보는 로그에만 기록 (보안 고려)

3. **예상치 못한 예외**:
   - 5000 에러 코드 반환
   - 상세한 에러 정보는 로그에만 기록
   - 클라이언트에는 일반적인 에러 메시지만 반환

---

## 예외 처리 흐름

### GlobalExceptionHandler

모든 예외를 중앙에서 처리하는 `GlobalExceptionHandler`를 구현합니다:

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // 비즈니스 예외 처리
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException e) {
        ErrorResponse errorResponse = ErrorResponse.builder()
            .code(e.getErrorCode())
            .messageCode(MessageCode.builder()
                .code(e.getMessageCode())
                .text(e.getMessage())
                .build())
            .build();
        return ResponseEntity
            .status(e.getHttpStatus())
            .body(errorResponse);
    }
    
    // 유효성 검증 예외 처리
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            MethodArgumentNotValidException e) {
        List<FieldError> fieldErrors = e.getBindingResult().getFieldErrors();
        ErrorResponse errorResponse = ErrorResponse.builder()
            .code("4006")
            .messageCode(MessageCode.builder()
                .code("VALIDATION_ERROR")
                .text("유효성 검증에 실패했습니다.")
                .build())
            .errors(fieldErrors.stream()
                .map(error -> FieldError.builder()
                    .field(error.getField())
                    .code(error.getCode())
                    .message(error.getDefaultMessage())
                    .build())
                .collect(Collectors.toList()))
            .build();
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(errorResponse);
    }
    
    // 인증 예외 처리
    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(
            AuthenticationException e) {
        ErrorResponse errorResponse = ErrorResponse.builder()
            .code("4001")
            .messageCode(MessageCode.builder()
                .code("AUTH_FAILED")
                .text("인증에 실패했습니다.")
                .build())
            .build();
        return ResponseEntity
            .status(HttpStatus.UNAUTHORIZED)
            .body(errorResponse);
    }
    
    // 권한 예외 처리
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDeniedException(
            AccessDeniedException e) {
        ErrorResponse errorResponse = ErrorResponse.builder()
            .code("4003")
            .messageCode(MessageCode.builder()
                .code("FORBIDDEN")
                .text("권한이 없습니다.")
                .build())
            .build();
        return ResponseEntity
            .status(HttpStatus.FORBIDDEN)
            .body(errorResponse);
    }
    
    // 리소스 없음 예외 처리
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(
            ResourceNotFoundException e) {
        ErrorResponse errorResponse = ErrorResponse.builder()
            .code("4004")
            .messageCode(MessageCode.builder()
                .code("NOT_FOUND")
                .text("리소스를 찾을 수 없습니다.")
                .build())
            .build();
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(errorResponse);
    }
    
    // 예상치 못한 예외 처리
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception e) {
        // 로그에 상세 정보 기록
        log.error("Unexpected error occurred", e);
        
        ErrorResponse errorResponse = ErrorResponse.builder()
            .code("5000")
            .messageCode(MessageCode.builder()
                .code("INTERNAL_SERVER_ERROR")
                .text("내부 서버 오류가 발생했습니다.")
                .build())
            .build();
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(errorResponse);
    }
}
```

### 비즈니스 예외 클래스

비즈니스 예외는 다음과 같이 정의합니다:

```java
public class BusinessException extends RuntimeException {
    private final String errorCode;
    private final String messageCode;
    private final HttpStatus httpStatus;
    
    public BusinessException(String errorCode, String messageCode, String message, HttpStatus httpStatus) {
        super(message);
        this.errorCode = errorCode;
        this.messageCode = messageCode;
        this.httpStatus = httpStatus;
    }
    
    // Getters
}
```

### 예외 사용 예시

```java
// 리소스 없음 예외
if (user == null) {
    throw new ResourceNotFoundException("4004", "NOT_FOUND", "사용자를 찾을 수 없습니다.");
}

// 권한 없음 예외
if (!user.getId().equals(currentUserId)) {
    throw new AccessDeniedException("4003", "FORBIDDEN", "권한이 없습니다.");
}

// 중복 데이터 예외
if (bookmarkRepository.existsByUserIdAndItemTypeAndItemId(userId, itemType, itemId)) {
    throw new ConflictException("4005", "CONFLICT", "이미 북마크된 항목입니다.");
}
```

---

## 에러 로깅 전략

### 로깅 레벨

- **ERROR**: 시스템 예외, 예상치 못한 예외
- **WARN**: 비즈니스 예외 (중요한 경우)
- **INFO**: 일반적인 비즈니스 예외 (선택적)

### 로깅 정보

에러 로그에는 다음 정보를 포함합니다:

- 에러 코드
- 에러 메시지
- 요청 정보 (URL, HTTP 메서드, 파라미터)
- 사용자 정보 (userId, IP 주소)
- 스택 트레이스 (시스템 예외, 예상치 못한 예외만)
- 요청 ID (트레이싱용)

### 로깅 예시

```java
log.error("Database error occurred: {}", e.getMessage(), e);
log.warn("Business exception: code={}, message={}, userId={}, requestId={}", 
    errorCode, message, userId, requestId);
```

---

## 결론

이 설계서는 HTTP 상태 코드와 비즈니스 에러 코드를 분리하여 상세한 에러 정보를 제공하는 전략을 제공합니다. 클라이언트가 에러를 명확히 구분하고 적절히 처리할 수 있도록 합니다.

### 주요 특징

1. ✅ **HTTP 상태 코드와 비즈니스 에러 코드 분리**: 프로토콜 레벨과 애플리케이션 레벨 에러 명확히 구분
2. ✅ **일관된 에러 응답 형식**: 모든 에러 응답이 동일한 구조를 따름
3. ✅ **상세한 에러 정보 제공**: 클라이언트가 에러를 처리할 수 있도록 충분한 정보 제공
4. ✅ **국제화 지원**: 에러 메시지 코드를 통한 다국어 지원
5. ✅ **중앙 집중식 예외 처리**: GlobalExceptionHandler를 통한 일관된 예외 처리

### 다음 단계

1. ErrorResponse DTO 클래스 생성
2. MessageCode DTO 클래스 생성
3. BusinessException 클래스 생성
4. GlobalExceptionHandler 구현
5. 비즈니스 예외 클래스 구현 (ResourceNotFoundException, ConflictException 등)
6. 에러 로깅 전략 구현

---

**문서 버전**: 1.0  
**최종 업데이트**: 2026-01-07  
**작성자**: Error Handling Strategy Architect

