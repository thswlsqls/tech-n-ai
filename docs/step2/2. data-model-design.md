# CQRS 패턴 기반 데이터 모델 설계서

**작성 일시**: 2026-01-07  
**대상**: Command Side (Aurora MySQL) 및 Query Side (MongoDB Atlas) 데이터 모델 설계  
**아키텍처**: CQRS 패턴 기반 (Command Side: 쓰기 전용, Query Side: 읽기 전용)

## 목차

1. [개요](#개요)
2. [Command Side 데이터 모델 (Aurora MySQL)](#command-side-데이터-모델-aurora-mysql)
3. [Query Side 데이터 모델 (MongoDB Atlas)](#query-side-데이터-모델-mongodb-atlas)
4. [실시간 동기화 전략](#실시간-동기화-전략)
5. [TSID 필드 기반 매핑](#tsid-필드-기반-매핑)

---

## 개요

이 설계서는 CQRS 패턴을 기반으로 한 데이터 모델 설계를 다룹니다. Command Side(Aurora MySQL)는 쓰기 전용으로 높은 정규화 수준을 유지하고, Query Side(MongoDB Atlas)는 읽기 전용으로 비정규화된 구조를 사용합니다.

### API 모듈별 데이터 모델

이 설계서는 다음 API 모듈들의 데이터 모델을 다룹니다:

- **api-auth**: `auth` 스키마 (providers, users, admins, refresh_tokens, email_verifications, user_history, admin_history)
  - `api-auth-application.yml`에서 `module.aurora.schema=auth` 설정
  - `application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적 연결
- **api-bookmark**: `bookmark` 스키마 (bookmarks, bookmark_history)
  - `api-bookmark-application.yml`에서 `module.aurora.schema=bookmark` 설정
  - `application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적 연결
  - **주의사항**: `bookmarks` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key를 지원하지 않으므로 애플리케이션 레벨에서 참조 무결성을 보장해야 함
- **api-chatbot**: `chatbot` 스키마 (conversation_sessions, conversation_messages)
  - `api-chatbot-application.yml`에서 `module.aurora.schema=chatbot` 설정
  - `application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적 연결
  - **주의사항**: `conversation_sessions` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key를 지원하지 않으므로 애플리케이션 레벨에서 참조 무결성을 보장해야 함

### 설계 원칙

1. **Command Side (Aurora MySQL)**:
   - 높은 정규화 수준 (최소 3NF)
   - TSID Primary Key 사용
   - Soft Delete 패턴 적용
   - 인덱스 최소화 (쓰기 성능 최적화)

2. **Query Side (MongoDB Atlas)**:
   - 읽기 최적화를 위한 비정규화
   - ESR 규칙 준수 인덱스 설계
   - 프로젝션 최적화
   - TSID 필드 기반 동기화

3. **실시간 동기화**:
   - Kafka 이벤트 기반 동기화
   - TSID 필드 기반 1:1 매핑
   - 동기화 지연 시간: 1초 이내 목표

---

## Command Side 데이터 모델 (Aurora MySQL)

Command Side는 쓰기 전용으로 설계되었으며, 높은 정규화 수준을 유지합니다.

### 스키마 구조

Command Side는 API 모듈별로 독립적인 스키마를 사용합니다:

- **auth 스키마** (api-auth 모듈):
  - 관리 테이블: providers, users, admins, refresh_tokens, email_verifications, user_history, admin_history
  - 설정: `api-auth-application.yml`에서 `module.aurora.schema=auth` 설정
- **bookmark 스키마** (api-bookmark 모듈):
  - 관리 테이블: bookmarks, bookmark_history
  - 설정: `api-bookmark-application.yml`에서 `module.aurora.schema=bookmark` 설정
  - **주의사항**: `bookmarks` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key를 지원하지 않으므로 애플리케이션 레벨에서 참조 무결성을 보장해야 함
- **chatbot 스키마** (api-chatbot 모듈):
  - 관리 테이블: conversation_sessions, conversation_messages
  - 설정: `api-chatbot-application.yml`에서 `module.aurora.schema=chatbot` 설정
  - **주의사항**: `conversation_sessions` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key를 지원하지 않으므로 애플리케이션 레벨에서 참조 무결성을 보장해야 함

### 스키마 매핑 설정 방식

각 API 모듈은 자체 `application.yml` 파일에서 `module.aurora.schema` 속성을 설정하고, `domain/aurora/src/main/resources/application-api-domain.yml`에서 `${module.aurora.schema}` 환경변수를 사용하여 동적으로 스키마를 참조합니다.

**설정 구조**:
1. 각 API 모듈의 `api-*-application.yml` 파일에서 `module.aurora.schema` 설정
2. `domain/aurora/src/main/resources/application-api-domain.yml`에서 `${module.aurora.schema}` 사용

**DataSource URL 형식**:
```yaml
spring:
  datasource:
    writer:
      url: jdbc:mysql://${AURORA_WRITER_ENDPOINT}:3306/${module.aurora.schema}?${AURORA_OPTIONS}
      username: ${AURORA_USERNAME}
      password: ${AURORA_PASSWORD}
    reader:
      url: jdbc:mysql://${AURORA_READER_ENDPOINT}:3306/${module.aurora.schema}?${AURORA_OPTIONS}
      username: ${AURORA_USERNAME}
      password: ${AURORA_PASSWORD}
```

**참고**: 스키마 매핑 설정 방식에 대한 상세 내용은 `docs/phase1/3. aurora-schema-design.md` 문서를 참고하세요.

### 공통 사항

모든 엔티티는 다음 공통 필드를 포함합니다:

- **Primary Key**: `id` (BIGINT UNSIGNED, TSID)
- **Soft Delete**: `is_deleted` (BOOLEAN, 기본값 FALSE), `deleted_at` (TIMESTAMP(6)), `deleted_by` (BIGINT UNSIGNED)
- **감사 필드**: `created_at`, `created_by`, `updated_at`, `updated_by`

### Provider 엔티티

OAuth 제공자 정보를 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| name | VARCHAR(50) | UNIQUE, NOT NULL | 제공자 이름 (예: "GOOGLE", "GITHUB") |
| display_name | VARCHAR(100) | NOT NULL | 표시 이름 |
| client_id | VARCHAR(255) | NULL | OAuth Client ID |
| client_secret | VARCHAR(500) | NULL | OAuth Client Secret (암호화) |
| is_enabled | BOOLEAN | NOT NULL DEFAULT TRUE | 활성화 여부 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `name` UNIQUE 인덱스
- `is_enabled` 인덱스
- `is_deleted` 인덱스

---

### User 엔티티

사용자 정보를 저장하는 엔티티입니다. MongoDB Atlas의 `UserProfileDocument`와 실시간 동기화됩니다.

**스키마**: `auth` (api-auth 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| email | VARCHAR(100) | UNIQUE, NOT NULL | 이메일 |
| username | VARCHAR(50) | UNIQUE, NOT NULL | 사용자명 |
| password | VARCHAR(255) | NULL | 비밀번호 해시 (OAuth 사용자 제외) |
| provider_id | BIGINT UNSIGNED | FOREIGN KEY, NULL | Provider 테이블 참조 |
| provider_user_id | VARCHAR(255) | NULL | OAuth 제공자의 사용자 ID |
| is_email_verified | BOOLEAN | NOT NULL DEFAULT FALSE | 이메일 인증 완료 여부 |
| last_login_at | TIMESTAMP(6) | NULL | 마지막 로그인 일시 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `email` UNIQUE 인덱스
- `username` UNIQUE 인덱스
- `provider_id` 외래 키 인덱스
- `provider_id + provider_user_id` 복합 인덱스
- `is_deleted` 인덱스

#### 동기화 전략

- **동기화 대상**: MongoDB Atlas `UserProfileDocument`
- **동기화 매핑**: `User.id(TSID)` → `UserProfileDocument.userTsid` (1:1 매핑)
- **Kafka 이벤트**:
  - `UserCreatedEvent`: User 엔티티 생성 시 발행 → UserProfileDocument 생성
  - `UserUpdatedEvent`: User 엔티티 수정 시 발행 → UserProfileDocument 업데이트
  - `UserDeletedEvent`: User 엔티티 Soft Delete 시 발행 → UserProfileDocument 물리적 삭제
  - `UserRestoredEvent`: User 엔티티 복원 시 발행 → UserProfileDocument 새로 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)

---

### Admin 엔티티

관리자 정보를 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| email | VARCHAR(100) | UNIQUE, NOT NULL | 이메일 |
| username | VARCHAR(50) | UNIQUE, NOT NULL | 사용자명 |
| password | VARCHAR(255) | NOT NULL | 비밀번호 해시 |
| role | VARCHAR(50) | NOT NULL | 역할 (예: "SUPER_ADMIN", "ADMIN") |
| is_active | BOOLEAN | NOT NULL DEFAULT TRUE | 활성화 여부 |
| last_login_at | TIMESTAMP(6) | NULL | 마지막 로그인 일시 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `email` UNIQUE 인덱스
- `username` UNIQUE 인덱스
- `role` 인덱스
- `is_active` 인덱스
- `is_deleted` 인덱스

---

### Bookmark 엔티티

사용자가 북마크한 항목을 저장하는 엔티티입니다. MongoDB Atlas의 `BookmarkDocument`와 실시간 동기화됩니다.

**스키마**: `bookmark` (api-bookmark 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| user_id | BIGINT UNSIGNED | NOT NULL | auth 스키마의 users 테이블 참조 (스키마 간 Foreign Key 미지원) |
| item_type | VARCHAR(50) | NOT NULL | 항목 타입 (예: "CONTEST", "NEWS_ARTICLE") |
| item_id | VARCHAR(255) | NOT NULL | 항목 ID (MongoDB ObjectId 문자열) |
| tag | VARCHAR(100) | NULL | 태그 |
| memo | TEXT | NULL | 메모 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `user_id` 외래 키 인덱스
- `user_id + is_deleted` 복합 인덱스
- `user_id + item_type + item_id` UNIQUE 복합 인덱스 (중복 방지)

#### 제약조건

- `user_id + item_type + item_id` UNIQUE 제약조건 (Soft Delete 제외, 애플리케이션 레벨에서 처리)

#### 스키마 간 참조 주의사항

- **스키마 간 Foreign Key 제약조건**: `bookmarks` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key 제약조건을 지원하지 않으므로, 애플리케이션 레벨에서 참조 무결성을 보장해야 합니다.
  - `user_id` 값의 유효성 검증은 애플리케이션 레벨에서 수행해야 합니다.
  - `users` 테이블의 레코드 삭제 시 관련 `bookmarks` 레코드 처리도 애플리케이션 레벨에서 관리해야 합니다.

#### 동기화 전략

- **동기화 대상**: MongoDB Atlas `BookmarkDocument`
- **동기화 매핑**: `Bookmark.id(TSID)` → `BookmarkDocument.bookmarkTsid` (1:1 매핑)
- **Kafka 이벤트**:
  - `BookmarkCreatedEvent`: Bookmark 엔티티 생성 시 발행 → BookmarkDocument 생성
  - `BookmarkUpdatedEvent`: Bookmark 엔티티 수정 시 발행 → BookmarkDocument 업데이트
  - `BookmarkDeletedEvent`: Bookmark 엔티티 Soft Delete 시 발행 → BookmarkDocument 물리적 삭제
  - `BookmarkRestoredEvent`: Bookmark 엔티티 복원 시 발행 → BookmarkDocument 새로 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)

---

### RefreshToken 엔티티

JWT Refresh Token을 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| user_id | BIGINT UNSIGNED | FOREIGN KEY, NOT NULL | User 테이블 참조 |
| token | VARCHAR(500) | UNIQUE, NOT NULL | Refresh Token |
| expires_at | TIMESTAMP(6) | NOT NULL | 만료 일시 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NULL | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `token` UNIQUE 인덱스
- `user_id` 외래 키 인덱스
- `expires_at` 인덱스
- `is_deleted` 인덱스

---

### EmailVerification 엔티티

이메일 인증 정보를 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| email | VARCHAR(100) | NOT NULL | 인증 대상 이메일 |
| token | VARCHAR(255) | UNIQUE, NOT NULL | 인증 토큰 |
| type | VARCHAR(50) | NOT NULL | 토큰 타입 (예: "EMAIL_VERIFICATION", "PASSWORD_RESET") |
| expires_at | TIMESTAMP(6) | NOT NULL | 만료 일시 |
| verified_at | TIMESTAMP(6) | NULL | 인증 완료 일시 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NULL | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `token` UNIQUE 인덱스
- `email` 인덱스
- `email + type` 복합 인덱스 (동일 이메일의 여러 타입 토큰 구분용)
- `expires_at` 인덱스
- `is_deleted` 인덱스

---

### 히스토리 엔티티

모든 쓰기 작업에 대한 변경 이력을 추적하는 엔티티입니다.

#### UserHistory 엔티티

User 테이블의 변경 이력을 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

##### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| history_id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| user_id | BIGINT UNSIGNED | FOREIGN KEY, NOT NULL | User 테이블 참조 |
| operation_type | VARCHAR(20) | NOT NULL | 작업 타입 (INSERT, UPDATE, DELETE) |
| before_data | JSON | NULL | 변경 전 데이터 |
| after_data | JSON | NULL | 변경 후 데이터 |
| changed_by | BIGINT UNSIGNED | FOREIGN KEY, NULL | 변경한 사용자 ID |
| changed_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 변경 일시 |
| change_reason | VARCHAR(500) | NULL | 변경 사유 |

##### 인덱스

- `user_id` 외래 키 인덱스
- `changed_at` 인덱스
- `operation_type + changed_at` 복합 인덱스

#### AdminHistory 엔티티

Admin 테이블의 변경 이력을 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

##### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| history_id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| admin_id | BIGINT UNSIGNED | FOREIGN KEY, NOT NULL | Admin 테이블 참조 |
| operation_type | VARCHAR(20) | NOT NULL | 작업 타입 (INSERT, UPDATE, DELETE) |
| before_data | JSON | NULL | 변경 전 데이터 |
| after_data | JSON | NULL | 변경 후 데이터 |
| changed_by | BIGINT UNSIGNED | FOREIGN KEY, NULL | 변경한 관리자 ID |
| changed_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 변경 일시 |
| change_reason | VARCHAR(500) | NULL | 변경 사유 |

##### 인덱스

- `admin_id` 외래 키 인덱스
- `changed_at` 인덱스
- `operation_type + changed_at` 복합 인덱스

#### BookmarkHistory 엔티티

Bookmark 테이블의 변경 이력을 저장하는 엔티티입니다.

**스키마**: `bookmark` (api-bookmark 모듈)

##### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| history_id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| bookmark_id | BIGINT UNSIGNED | FOREIGN KEY, NOT NULL | Bookmark 테이블 참조 |
| operation_type | VARCHAR(20) | NOT NULL | 작업 타입 (INSERT, UPDATE, DELETE) |
| before_data | JSON | NULL | 변경 전 데이터 |
| after_data | JSON | NULL | 변경 후 데이터 |
| changed_by | BIGINT UNSIGNED | FOREIGN KEY, NULL | 변경한 사용자 ID |
| changed_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 변경 일시 |
| change_reason | VARCHAR(500) | NULL | 변경 사유 |

##### 인덱스

- `bookmark_id` 외래 키 인덱스
- `changed_at` 인덱스
- `operation_type + changed_at` 복합 인덱스

**주의**: `operation_type='DELETE'`는 실제 SQL DELETE가 아닌 Soft Delete를 의미합니다.

---

### ConversationSession 엔티티

대화 세션 정보를 저장하는 엔티티입니다. MongoDB Atlas의 `ConversationSessionDocument`와 실시간 동기화됩니다.

**스키마**: `chatbot` (api-chatbot 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| session_id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| user_id | BIGINT UNSIGNED | NOT NULL | auth 스키마의 users 테이블 참조 (스키마 간 Foreign Key 미지원) |
| title | VARCHAR(200) | NULL | 세션 제목 (선택) |
| last_message_at | TIMESTAMP(6) | NOT NULL | 마지막 메시지 시간 |
| is_active | BOOLEAN | NOT NULL DEFAULT TRUE | 활성 세션 여부 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `session_id` PRIMARY KEY
- `user_id + is_active + last_message_at` 복합 인덱스 (사용자별 활성 세션 조회 최적화)

#### 스키마 간 참조 주의사항

- **스키마 간 Foreign Key 제약조건**: `conversation_sessions` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key 제약조건을 지원하지 않으므로, 애플리케이션 레벨에서 참조 무결성을 보장해야 합니다.
  - `user_id` 값의 유효성 검증은 애플리케이션 레벨에서 수행해야 합니다.
  - `users` 테이블의 레코드 삭제 시 관련 `conversation_sessions` 레코드 처리도 애플리케이션 레벨에서 관리해야 합니다.

#### 동기화 전략

- **동기화 대상**: MongoDB Atlas `ConversationSessionDocument`
- **동기화 매핑**: `ConversationSession.session_id(TSID)` → `ConversationSessionDocument.session_id` (1:1 매핑)
- **Kafka 이벤트**:
  - `ConversationSessionCreatedEvent`: ConversationSession 엔티티 생성 시 발행 → ConversationSessionDocument 생성
  - `ConversationSessionUpdatedEvent`: ConversationSession 엔티티 수정 시 발행 → ConversationSessionDocument 업데이트
  - `ConversationSessionDeletedEvent`: ConversationSession 엔티티 Soft Delete 시 발행 → ConversationSessionDocument 물리적 삭제
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)

---

### ConversationMessage 엔티티

대화 메시지 히스토리를 저장하는 엔티티입니다. MongoDB Atlas의 `ConversationMessageDocument`와 실시간 동기화됩니다.

**스키마**: `chatbot` (api-chatbot 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| message_id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| session_id | BIGINT UNSIGNED | FOREIGN KEY, NOT NULL | ConversationSession 테이블 참조 |
| role | VARCHAR(20) | NOT NULL | 메시지 역할 (USER, ASSISTANT, SYSTEM) |
| content | TEXT | NOT NULL | 메시지 내용 |
| token_count | INT | NULL | 토큰 수 (비용 계산용) |
| sequence_number | INT | NOT NULL | 대화 순서 (1부터 시작) |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |

#### 인덱스

- `message_id` PRIMARY KEY
- `session_id` 외래 키 인덱스
- `session_id + sequence_number` 복합 인덱스 (세션별 메시지 순서 조회 최적화)

#### Foreign Key

```sql
ALTER TABLE conversation_messages
ADD CONSTRAINT fk_message_session
FOREIGN KEY (session_id) REFERENCES conversation_sessions(session_id)
ON DELETE CASCADE;
```

#### 동기화 전략

- **동기화 대상**: MongoDB Atlas `ConversationMessageDocument`
- **동기화 매핑**: `ConversationMessage.message_id(TSID)` → `ConversationMessageDocument.message_id` (1:1 매핑)
- **Kafka 이벤트**:
  - `ConversationMessageCreatedEvent`: ConversationMessage 엔티티 생성 시 발행 → ConversationMessageDocument 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)

---

## Query Side 데이터 모델 (MongoDB Atlas)

Query Side는 읽기 전용으로 설계되었으며, 읽기 성능 최적화를 위해 비정규화된 구조를 사용합니다.

### 공통 사항

모든 도큐먼트는 다음 공통 필드를 포함합니다:

- **Primary Key**: `_id` (ObjectId)
- **감사 필드**: `createdAt`, `createdBy`, `updatedAt`, `updatedBy`
- **인덱스 전략**: ESR 규칙 (Equality → Sort → Range) 준수

> Contest/News 수집 기능 폐기로 SourcesDocument, ContestDocument, NewsArticleDocument 섹션 삭제됨

### BookmarkDocument

사용자가 북마크한 항목을 저장하는 도큐먼트입니다. Aurora MySQL의 `Bookmark` 엔티티와 실시간 동기화됩니다.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  bookmarkTsid: String,              // Aurora MySQL Bookmark 테이블 TSID PK 값 (BIGINT UNSIGNED, UNIQUE)
  userId: String,                   // 사용자 ID (Command Side의 User 테이블 참조)
  itemType: String,                 // 항목 타입: "CONTEST", "NEWS_ARTICLE"
  itemId: ObjectId,                 // 항목 ID (ContestDocument 또는 NewsArticleDocument 참조)
  itemTitle: String,                // 항목 제목 (비정규화)
  itemSummary: String,              // 항목 요약 (비정규화)
  tag: String,                      // 태그 (nullable)
  memo: String,                     // 메모 (nullable)
  bookmarkedAt: Date,                 // 북마크 일시
  createdAt: Date,                  // 생성 일시
  createdBy: String,                // 생성자 ID (nullable)
  updatedAt: Date,                  // 수정 일시
  updatedBy: String                 // 수정자 ID (nullable)
}
```

#### 인덱스

- `bookmarkTsid` UNIQUE 인덱스 (Aurora MySQL 동기화용)
- `userId + createdAt` 복합 인덱스 (ESR 규칙: E, S)
- `userId + itemType + createdAt` 복합 인덱스 (ESR 규칙: E, E, S)
- `userId + itemType + itemId` UNIQUE 복합 인덱스 (중복 방지)

#### 비정규화

- `itemTitle`, `itemSummary`: 항목 제목/요약 중복 저장 (ContestDocument/NewsArticleDocument 조인 불필요)

#### 동기화 전략

- **동기화 대상**: Aurora MySQL `Bookmark` 엔티티
- **동기화 매핑**: `Bookmark.id(TSID)` → `BookmarkDocument.bookmarkTsid` (1:1 매핑)
- **Kafka 이벤트**:
  - `BookmarkCreatedEvent`: Bookmark 엔티티 생성 시 발행 → BookmarkDocument 생성
  - `BookmarkUpdatedEvent`: Bookmark 엔티티 수정 시 발행 → BookmarkDocument 업데이트
    - **주의**: `updatedFields`에는 `tag`, `memo`만 포함 가능 (BookmarkEntity에 있는 필드만)
    - `itemTitle`, `itemSummary`는 BookmarkEntity에 없는 필드이므로 `updatedFields`에 포함될 수 없음
    - 원본 아이템 변경 시 별도의 동기화 메커니즘으로 `BookmarkDocument`의 `itemTitle`, `itemSummary`를 업데이트해야 함
  - `BookmarkDeletedEvent`: Bookmark 엔티티 Soft Delete 시 발행 → BookmarkDocument 물리적 삭제
  - `BookmarkRestoredEvent`: Bookmark 엔티티 복원 시 발행 → BookmarkDocument 새로 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)
- **MongoDB Soft Delete 미지원**: Soft Delete 시 Document 물리적 삭제, 복원 시 Document 새로 생성

---

### UserProfileDocument

사용자 프로필 정보를 저장하는 도큐먼트입니다. Aurora MySQL의 `User` 엔티티와 실시간 동기화됩니다.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  userTsid: String,                 // Aurora MySQL User 테이블 TSID PK 값 (BIGINT UNSIGNED, UNIQUE)
  userId: String,                   // 사용자 ID (UNIQUE, Command Side의 User 테이블 참조)
  username: String,                // 사용자명 (UNIQUE)
  email: String,                   // 이메일 (UNIQUE)
  profileImageUrl: String,         // 프로필 이미지 URL (nullable)
  createdAt: Date,                 // 생성 일시
  createdBy: String,               // 생성자 ID (nullable)
  updatedAt: Date,                 // 수정 일시
  updatedBy: String                // 수정자 ID (nullable)
}
```

#### 인덱스

- `userTsid` UNIQUE 인덱스 (Aurora MySQL 동기화용)
- `userId` UNIQUE 인덱스
- `username` UNIQUE 인덱스
- `email` UNIQUE 인덱스

#### 동기화 전략

- **동기화 대상**: Aurora MySQL `User` 엔티티
- **동기화 매핑**: `User.id(TSID)` → `UserProfileDocument.userTsid` (1:1 매핑)
- **Kafka 이벤트**:
  - `UserCreatedEvent`: User 엔티티 생성 시 발행 → UserProfileDocument 생성
  - `UserUpdatedEvent`: User 엔티티 수정 시 발행 → UserProfileDocument 업데이트
  - `UserDeletedEvent`: User 엔티티 Soft Delete 시 발행 → UserProfileDocument 물리적 삭제
  - `UserRestoredEvent`: User 엔티티 복원 시 발행 → UserProfileDocument 새로 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)
- **MongoDB Soft Delete 미지원**: Soft Delete 시 Document 물리적 삭제, 복원 시 Document 새로 생성

---

### ConversationSessionDocument

대화 세션 정보를 저장하는 도큐먼트입니다. Aurora MySQL의 `ConversationSession` 엔티티와 실시간 동기화됩니다.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  session_id: String,               // Aurora MySQL ConversationSession 테이블 TSID PK 값 (BIGINT UNSIGNED, UNIQUE)
  user_id: String,                  // 사용자 ID (Command Side의 User 테이블 참조)
  title: String,                    // 세션 제목 (nullable)
  last_message_at: Date,            // 마지막 메시지 시간
  is_active: Boolean,               // 활성 세션 여부
  created_at: Date,                 // 생성 일시
  updated_at: Date                  // 수정 일시
}
```

#### 인덱스

- `session_id` UNIQUE 인덱스 (Aurora MySQL 동기화용)
- `user_id + is_active + last_message_at` 복합 인덱스 (ESR 규칙: E, E, S)
- `last_message_at` TTL 인덱스 (90일 후 자동 삭제)

#### 동기화 전략

- **동기화 대상**: Aurora MySQL `ConversationSession` 엔티티
- **동기화 매핑**: `ConversationSession.session_id(TSID)` → `ConversationSessionDocument.session_id` (1:1 매핑)
- **Kafka 이벤트**:
  - `ConversationSessionCreatedEvent`: ConversationSession 엔티티 생성 시 발행 → ConversationSessionDocument 생성
  - `ConversationSessionUpdatedEvent`: ConversationSession 엔티티 수정 시 발행 → ConversationSessionDocument 업데이트
  - `ConversationSessionDeletedEvent`: ConversationSession 엔티티 Soft Delete 시 발행 → ConversationSessionDocument 물리적 삭제
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)
- **MongoDB Soft Delete 미지원**: Soft Delete 시 Document 물리적 삭제

---

### ConversationMessageDocument

대화 메시지 히스토리를 저장하는 도큐먼트입니다. Aurora MySQL의 `ConversationMessage` 엔티티와 실시간 동기화됩니다.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  message_id: String,               // Aurora MySQL ConversationMessage 테이블 TSID PK 값 (BIGINT UNSIGNED, UNIQUE)
  session_id: String,               // 세션 ID (ConversationSessionDocument 참조)
  role: String,                    // 메시지 역할: "USER", "ASSISTANT", "SYSTEM"
  content: String,                  // 메시지 내용
  token_count: Integer,             // 토큰 수 (nullable)
  sequence_number: Integer,        // 대화 순서 (1부터 시작)
  created_at: Date                 // 생성 일시
}
```

#### 인덱스

- `message_id` UNIQUE 인덱스 (Aurora MySQL 동기화용)
- `session_id + sequence_number` 복합 인덱스 (ESR 규칙: E, S)
- `created_at` TTL 인덱스 (1년 후 자동 삭제)

#### 동기화 전략

- **동기화 대상**: Aurora MySQL `ConversationMessage` 엔티티
- **동기화 매핑**: `ConversationMessage.message_id(TSID)` → `ConversationMessageDocument.message_id` (1:1 매핑)
- **Kafka 이벤트**:
  - `ConversationMessageCreatedEvent`: ConversationMessage 엔티티 생성 시 발행 → ConversationMessageDocument 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)

---

### ExceptionLogDocument

예외 로그를 저장하는 도큐먼트입니다. 읽기/쓰기 예외를 모두 기록합니다.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  source: String,                   // 예외 소스: "READ", "WRITE"
  exceptionType: String,            // 예외 타입 (예: "DataAccessException", "ValidationException")
  exceptionMessage: String,         // 예외 메시지
  stackTrace: String,               // 스택 트레이스 (전체)
  context: {                         // 컨텍스트 정보 (Object)
    module: String,                 // 모듈명
    method: String,                 // 메서드명
    parameters: Object,             // 파라미터 정보
    userId: String,                 // 사용자 ID (nullable)
    requestId: String               // 요청 ID (nullable)
  },
  occurredAt: Date,                  // 발생 일시
  severity: String,                  // 심각도: "LOW", "MEDIUM", "HIGH", "CRITICAL"
  createdAt: Date,                   // 생성 일시
  createdBy: String,                 // 생성자 ID (nullable)
  updatedAt: Date,                  // 수정 일시
  updatedBy: String                 // 수정자 ID (nullable)
}
```

#### 인덱스

- `source + occurredAt` 복합 인덱스 (ESR 규칙: E, S)
- `exceptionType + occurredAt` 복합 인덱스 (ESR 규칙: E, S)
- `occurredAt` TTL 인덱스 (90일 후 자동 삭제)

---

## 실시간 동기화 전략

### 동기화 원칙

1. **이벤트 기반 동기화**: 모든 쓰기 작업 후 Kafka 이벤트 발행
2. **TSID 필드 기반 매핑**: 1:1 매핑으로 동기화 정확성 보장
3. **실시간 동기화**: 동기화 지연 시간 1초 이내 목표
4. **MongoDB Soft Delete 미지원**: Soft Delete 시 Document 물리적 삭제, 복원 시 Document 새로 생성

### User 엔티티 → UserProfileDocument 동기화

#### 동기화 흐름

1. **User 엔티티 생성**:
   - Aurora MySQL `User` 엔티티 생성
   - `UserHistory` 엔티티 생성 (operation_type: INSERT)
   - **Kafka 이벤트 발행**: `UserCreatedEvent`
     - 페이로드: `userTsid` (User.id), `userId`, `username`, `email`, `profileImageUrl` 등
   - MongoDB Atlas `UserProfileDocument` 생성 (userTsid 필드 활용)

2. **User 엔티티 수정**:
   - Aurora MySQL `User` 엔티티 업데이트
   - `UserHistory` 엔티티 생성 (operation_type: UPDATE)
   - **Kafka 이벤트 발행**: `UserUpdatedEvent`
     - 페이로드: `userTsid`, 변경된 필드 정보 포함
   - MongoDB Atlas `UserProfileDocument` 업데이트 (userTsid 필드 활용)

3. **User 엔티티 Soft Delete**:
   - Aurora MySQL `User` 엔티티 Soft Delete (is_deleted=TRUE, deleted_at 설정)
   - `UserHistory` 엔티티 생성 (operation_type: DELETE)
   - **Kafka 이벤트 발행**: `UserDeletedEvent`
     - 페이로드: `userTsid`, `userId`, `deletedAt` 등
   - MongoDB Atlas `UserProfileDocument` 물리적 삭제 (MongoDB는 Soft Delete 미지원)

4. **User 엔티티 복원**:
   - Aurora MySQL `User` 엔티티 복원 (is_deleted=FALSE, deleted_at=null)
   - `UserHistory` 엔티티 생성 (operation_type: UPDATE)
   - **Kafka 이벤트 발행**: `UserRestoredEvent`
     - 페이로드: `userTsid`, `userId`, `username`, `email`, `profileImageUrl` 등
   - MongoDB Atlas `UserProfileDocument` 새로 생성 (MongoDB는 Soft Delete 미지원이므로 복원 시 재생성 필요)

#### 동기화 매핑

- `User.id(TSID)` → `UserProfileDocument.userTsid` (1:1 매핑)
- `userTsid` 필드를 통해 정확한 동기화 보장

#### 동기화 지연 시간

- 목표: 1초 이내
- Kafka 이벤트 발행 후 즉시 MongoDB Atlas 동기화

---

### ConversationSession 엔티티 → ConversationSessionDocument 동기화

#### 동기화 흐름

1. **ConversationSession 엔티티 생성**:
   - Aurora MySQL `ConversationSession` 엔티티 생성
   - **Kafka 이벤트 발행**: `ConversationSessionCreatedEvent`
     - 페이로드: `sessionId` (ConversationSession.session_id), `userId`, `title`, `lastMessageAt`, `isActive` 등
   - MongoDB Atlas `ConversationSessionDocument` 생성 (session_id 필드 활용)

2. **ConversationSession 엔티티 수정**:
   - Aurora MySQL `ConversationSession` 엔티티 업데이트
   - **Kafka 이벤트 발행**: `ConversationSessionUpdatedEvent`
     - 페이로드: `sessionId`, 변경된 필드 정보 포함
   - MongoDB Atlas `ConversationSessionDocument` 업데이트 (session_id 필드 활용)

3. **ConversationSession 엔티티 Soft Delete**:
   - Aurora MySQL `ConversationSession` 엔티티 Soft Delete (is_deleted=TRUE, deleted_at 설정)
   - **Kafka 이벤트 발행**: `ConversationSessionDeletedEvent`
     - 페이로드: `sessionId`, `userId`, `deletedAt` 등
   - MongoDB Atlas `ConversationSessionDocument` 물리적 삭제 (MongoDB는 Soft Delete 미지원)

#### 동기화 매핑

- `ConversationSession.session_id(TSID)` → `ConversationSessionDocument.session_id` (1:1 매핑)
- `session_id` 필드를 통해 정확한 동기화 보장

#### 동기화 지연 시간

- 목표: 1초 이내
- Kafka 이벤트 발행 후 즉시 MongoDB Atlas 동기화

---

### ConversationMessage 엔티티 → ConversationMessageDocument 동기화

#### 동기화 흐름

1. **ConversationMessage 엔티티 생성**:
   - Aurora MySQL `ConversationMessage` 엔티티 생성
   - **Kafka 이벤트 발행**: `ConversationMessageCreatedEvent`
     - 페이로드: `messageId` (ConversationMessage.message_id), `sessionId`, `role`, `content`, `tokenCount`, `sequenceNumber` 등
   - MongoDB Atlas `ConversationMessageDocument` 생성 (message_id 필드 활용)

#### 동기화 매핑

- `ConversationMessage.message_id(TSID)` → `ConversationMessageDocument.message_id` (1:1 매핑)
- `message_id` 필드를 통해 정확한 동기화 보장

#### 동기화 지연 시간

- 목표: 1초 이내
- Kafka 이벤트 발행 후 즉시 MongoDB Atlas 동기화

---

### Bookmark 엔티티 → BookmarkDocument 동기화

#### 동기화 흐름

1. **Bookmark 엔티티 생성**:
   - Aurora MySQL `Bookmark` 엔티티 생성
   - `BookmarkHistory` 엔티티 생성 (operation_type: INSERT)
   - **Kafka 이벤트 발행**: `BookmarkCreatedEvent`
     - 페이로드: `bookmarkTsid` (Bookmark.id), `userId`, `itemType`, `itemId`, `tag`, `memo` 등
   - MongoDB Atlas `BookmarkDocument` 생성 (bookmarkTsid 필드 활용)

2. **Bookmark 엔티티 수정**:
   - Aurora MySQL `Bookmark` 엔티티 업데이트
   - `BookmarkHistory` 엔티티 생성 (operation_type: UPDATE)
   - **Kafka 이벤트 발행**: `BookmarkUpdatedEvent`
     - 페이로드: `bookmarkTsid`, 변경된 필드 정보 포함
   - MongoDB Atlas `BookmarkDocument` 업데이트 (bookmarkTsid 필드 활용)

3. **Bookmark 엔티티 Soft Delete**:
   - Aurora MySQL `Bookmark` 엔티티 Soft Delete (is_deleted=TRUE, deleted_at 설정)
   - `BookmarkHistory` 엔티티 생성 (operation_type: DELETE)
   - **Kafka 이벤트 발행**: `BookmarkDeletedEvent`
     - 페이로드: `bookmarkTsid`, `userId`, `deletedAt` 등
   - MongoDB Atlas `BookmarkDocument` 물리적 삭제 (MongoDB는 Soft Delete 미지원)

4. **Bookmark 엔티티 복원**:
   - Aurora MySQL `Bookmark` 엔티티 복원 (is_deleted=FALSE, deleted_at=null)
   - `BookmarkHistory` 엔티티 생성 (operation_type: UPDATE)
   - **Kafka 이벤트 발행**: `BookmarkRestoredEvent`
     - 페이로드: `bookmarkTsid`, `userId`, `itemType`, `itemId`, `tag`, `memo` 등
   - MongoDB Atlas `BookmarkDocument` 새로 생성 (MongoDB는 Soft Delete 미지원이므로 복원 시 재생성 필요)

#### 동기화 매핑

- `Bookmark.id(TSID)` → `BookmarkDocument.bookmarkTsid` (1:1 매핑)
- `bookmarkTsid` 필드를 통해 정확한 동기화 보장

#### 동기화 지연 시간

- 목표: 1초 이내
- Kafka 이벤트 발행 후 즉시 MongoDB Atlas 동기화

---

### Kafka 이벤트 설계

#### 이벤트 공통 구조

```json
{
  "eventId": "event-uuid",
  "eventType": "UserCreatedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    // 이벤트별 페이로드
  }
}
```

#### UserCreatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "UserCreatedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "userTsid": "9876543210987654321",
    "userId": "user123",
    "username": "john_doe",
    "email": "john@example.com",
    "profileImageUrl": "https://example.com/avatars/john.jpg"
  }
}
```

#### UserUpdatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "UserUpdatedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "userTsid": "9876543210987654321",
    "userId": "user123",
    "updatedFields": {
      "username": "updated_john_doe",
      "profileImageUrl": "https://example.com/avatars/updated_john.jpg"
    }
  }
}
```

#### UserDeletedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "UserDeletedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "userTsid": "9876543210987654321",
    "userId": "user123",
    "deletedAt": "2026-01-07T10:00:00Z"
  }
}
```

#### UserRestoredEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "UserRestoredEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "userTsid": "9876543210987654321",
    "userId": "user123",
    "username": "john_doe",
    "email": "john@example.com",
    "profileImageUrl": "https://example.com/avatars/john.jpg"
  }
}
```

#### BookmarkCreatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "BookmarkCreatedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "bookmarkTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "itemTitle": "Codeforces Round 900",
    "itemSummary": "Regular Codeforces contest",
    "tag": "algorithm",
    "memo": "참가 예정",
    "bookmarkedAt": "2026-01-07T10:00:00Z"
  }
}
```

#### BookmarkUpdatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "BookmarkUpdatedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "bookmarkTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "updatedFields": {
      "tag": "updated-algorithm",
      "memo": "수정된 메모"
    }
  }
}
```

#### BookmarkDeletedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "BookmarkDeletedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "bookmarkTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "deletedAt": "2026-01-08T10:00:00Z"
  }
}
```

#### BookmarkRestoredEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "BookmarkRestoredEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "bookmarkTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "itemTitle": "Codeforces Round 900",
    "itemSummary": "Regular Codeforces contest",
    "tag": "algorithm",
    "memo": "참가 예정",
    "bookmarkedAt": "2026-01-07T10:00:00Z"
  }
}
```

#### ConversationSessionCreatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ConversationSessionCreatedEvent",
  "timestamp": "2026-01-16T10:00:00Z",
  "payload": {
    "sessionId": "1234567890123456789",
    "userId": "9876543210987654321",
    "title": "대화 세션 제목",
    "lastMessageAt": "2026-01-16T10:00:00Z",
    "isActive": true
  }
}
```

#### ConversationSessionUpdatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ConversationSessionUpdatedEvent",
  "timestamp": "2026-01-16T10:00:00Z",
  "payload": {
    "sessionId": "1234567890123456789",
    "updatedFields": {
      "title": "수정된 세션 제목",
      "lastMessageAt": "2026-01-16T11:00:00Z",
      "isActive": true
    }
  }
}
```

#### ConversationSessionDeletedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ConversationSessionDeletedEvent",
  "timestamp": "2026-01-16T10:00:00Z",
  "payload": {
    "sessionId": "1234567890123456789",
    "userId": "9876543210987654321",
    "deletedAt": "2026-01-16T10:00:00Z"
  }
}
```

#### ConversationMessageCreatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ConversationMessageCreatedEvent",
  "timestamp": "2026-01-16T10:00:00Z",
  "payload": {
    "messageId": "2345678901234567890",
    "sessionId": "1234567890123456789",
    "role": "USER",
    "content": "사용자 메시지 내용",
    "tokenCount": 50,
    "sequenceNumber": 1
  }
}
```

---

### 동기화 보장 전략

#### 멱등성 보장

- 이벤트 ID 기반 중복 처리 방지
- 동일한 이벤트 ID로 여러 번 수신되어도 한 번만 처리

#### 순서 보장

- Partition Key를 `userId` 또는 `bookmarkTsid`로 설정하여 사용자별/북마크별 순서 보장
- 동일한 사용자/북마크의 이벤트는 순서대로 처리

#### 트랜잭션 관리

- DB 커밋 후 Kafka 이벤트 발행 (트랜잭션 아웃박스 패턴 고려)
- 이벤트 발행 실패 시 재시도 로직

#### TSID 필드 기반 매핑

- `userTsid`, `bookmarkTsid`, `session_id`, `message_id` 필드를 통해 정확한 1:1 매핑 보장
- 동기화 실패 시 재시도 로직 실행 (최대 3회)
- 재시도 실패 시 Dead Letter Queue 처리

#### 동기화 상태 모니터링

- 동기화 지연 시간 모니터링
- 동기화 실패율 모니터링
- 알림 및 경고 설정

---

## TSID 필드 기반 매핑

### 매핑 전략

Command Side의 TSID Primary Key를 Query Side의 UNIQUE 필드로 매핑하여 1:1 관계를 보장합니다.

### User → UserProfileDocument 매핑

- **Command Side**: `User.id` (BIGINT UNSIGNED, TSID)
- **Query Side**: `UserProfileDocument.userTsid` (String, UNIQUE)
- **매핑 방식**: `User.id` 값을 문자열로 변환하여 `UserProfileDocument.userTsid`에 저장
- **동기화 확인**: `userTsid` 필드로 정확한 매핑 확인

### Bookmark → BookmarkDocument 매핑

- **Command Side**: `Bookmark.id` (BIGINT UNSIGNED, TSID)
- **Query Side**: `BookmarkDocument.bookmarkTsid` (String, UNIQUE)
- **매핑 방식**: `Bookmark.id` 값을 문자열로 변환하여 `BookmarkDocument.bookmarkTsid`에 저장
- **동기화 확인**: `bookmarkTsid` 필드로 정확한 매핑 확인

### ConversationSession → ConversationSessionDocument 매핑

- **Command Side**: `ConversationSession.session_id` (BIGINT UNSIGNED, TSID)
- **Query Side**: `ConversationSessionDocument.session_id` (String, UNIQUE)
- **매핑 방식**: `ConversationSession.session_id` 값을 문자열로 변환하여 `ConversationSessionDocument.session_id`에 저장
- **동기화 확인**: `session_id` 필드로 정확한 매핑 확인

### ConversationMessage → ConversationMessageDocument 매핑

- **Command Side**: `ConversationMessage.message_id` (BIGINT UNSIGNED, TSID)
- **Query Side**: `ConversationMessageDocument.message_id` (String, UNIQUE)
- **매핑 방식**: `ConversationMessage.message_id` 값을 문자열로 변환하여 `ConversationMessageDocument.message_id`에 저장
- **동기화 확인**: `message_id` 필드로 정확한 매핑 확인

### 매핑 장점

1. **정확성**: TSID 필드 기반 1:1 매핑으로 동기화 정확성 보장
2. **성능**: UNIQUE 인덱스로 빠른 조회 가능
3. **추적성**: 동기화 상태를 쉽게 확인 가능
4. **복구**: 동기화 실패 시 재시도 가능

---

## 결론

이 설계서는 CQRS 패턴을 기반으로 한 데이터 모델 설계를 제공합니다. Command Side는 쓰기 최적화를 위해 높은 정규화 수준을 유지하고, Query Side는 읽기 최적화를 위해 비정규화된 구조를 사용합니다. Kafka 이벤트 기반 실시간 동기화를 통해 데이터 일관성을 보장합니다.

### 주요 특징

1. ✅ **CQRS 패턴 적용**: Command Side와 Query Side 명확히 분리
2. ✅ **TSID Primary Key**: 모든 Command Side 엔티티에 TSID 적용
3. ✅ **Soft Delete**: Command Side에서 Soft Delete 구현
4. ✅ **비정규화**: Query Side에서 읽기 최적화를 위한 비정규화
5. ✅ **실시간 동기화**: Kafka 이벤트 기반 1초 이내 동기화 목표
6. ✅ **TSID 필드 기반 매핑**: 1:1 매핑으로 동기화 정확성 보장

### 다음 단계

1. JPA Entity 클래스 생성 (Command Side)
2. MongoDB Document 클래스 생성 (Query Side)
3. Repository 인터페이스 생성
4. Kafka 이벤트 발행 로직 구현
5. MongoDB Atlas 동기화 컨슈머 구현
6. 동기화 모니터링 시스템 구축

---

**문서 버전**: 1.1  
**최종 업데이트**: 2026-01-16  
**작성자**: Data Model Architect

### 변경 이력

- **v1.1 (2026-01-16)**: 
  - `ConversationSession` 엔티티 추가 (RAG 챗봇 대화 세션 관리)
  - `ConversationMessage` 엔티티 추가 (RAG 챗봇 대화 메시지 히스토리)
  - `ConversationSessionDocument` 추가 (MongoDB Atlas)
  - `ConversationMessageDocument` 추가 (MongoDB Atlas)
  - 관련 Kafka 이벤트 및 동기화 전략 추가
  - TSID 필드 기반 매핑 전략 확장
- **v1.0 (2026-01-07)**: 초기 버전

