# CQRS 패턴 기반 데이터 모델 설계서

**작성 일시**: 2026-01-07  
**대상**: Command Side (Aurora MySQL) 및 Query Side (MongoDB Atlas) 데이터 모델 설계  
**아키텍처**: CQRS 패턴 기반 (Command Side: 쓰기 전용, Query Side: 읽기 전용)

## 목차

1. [개요](#개요)
2. [Command Side 데이터 모델 (Aurora MySQL)](#command-side-데이터-모델-aurora-mysql)
3. [Query Side 데이터 모델 (MongoDB Atlas)](#query-side-데이터-모델-mongodb-atlas)
4. [실시간 동기화 전략](#실시간-동기화-전략)
5. [TSID 필드 기반 매핑](#tsid-필드-기반-매핑)

---

## 개요

이 설계서는 CQRS 패턴을 기반으로 한 데이터 모델 설계를 다룹니다. Command Side(Aurora MySQL)는 쓰기 전용으로 높은 정규화 수준을 유지하고, Query Side(MongoDB Atlas)는 읽기 전용으로 비정규화된 구조를 사용합니다.

### API 모듈별 데이터 모델

이 설계서는 다음 API 모듈들의 데이터 모델을 다룹니다:

- **api-auth**: `auth` 스키마 (providers, users, admins, refresh_tokens, email_verifications, user_history, admin_history)
  - `api-auth-application.yml`에서 `module.aurora.schema=auth` 설정
  - `application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적 연결
- **api-archive**: `archive` 스키마 (archives, archive_history)
  - `api-archive-application.yml`에서 `module.aurora.schema=archive` 설정
  - `application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적 연결
  - **주의사항**: `archives` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key를 지원하지 않으므로 애플리케이션 레벨에서 참조 무결성을 보장해야 함
- **api-contest**: MongoDB Atlas 사용 (ContestDocument)
  - Contest 데이터의 특성과 읽기 위주 요청이 필요한 비즈니스 요구사항에 따라 MongoDB Atlas 사용
  - Aurora DB를 사용하지 않음
- **api-news**: MongoDB Atlas 사용 (NewsArticleDocument)
  - News 데이터의 특성과 읽기 위주 요청이 필요한 비즈니스 요구사항에 따라 MongoDB Atlas 사용
  - Aurora DB를 사용하지 않음
- **api-chatbot**: `chatbot` 스키마 (conversation_sessions, conversation_messages)
  - `api-chatbot-application.yml`에서 `module.aurora.schema=chatbot` 설정
  - `application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적 연결
  - **주의사항**: `conversation_sessions` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key를 지원하지 않으므로 애플리케이션 레벨에서 참조 무결성을 보장해야 함

### 설계 원칙

1. **Command Side (Aurora MySQL)**:
   - 높은 정규화 수준 (최소 3NF)
   - TSID Primary Key 사용
   - Soft Delete 패턴 적용
   - 인덱스 최소화 (쓰기 성능 최적화)

2. **Query Side (MongoDB Atlas)**:
   - 읽기 최적화를 위한 비정규화
   - ESR 규칙 준수 인덱스 설계
   - 프로젝션 최적화
   - TSID 필드 기반 동기화

3. **실시간 동기화**:
   - Kafka 이벤트 기반 동기화
   - TSID 필드 기반 1:1 매핑
   - 동기화 지연 시간: 1초 이내 목표

---

## Command Side 데이터 모델 (Aurora MySQL)

Command Side는 쓰기 전용으로 설계되었으며, 높은 정규화 수준을 유지합니다.

### 스키마 구조

Command Side는 API 모듈별로 독립적인 스키마를 사용합니다:

- **auth 스키마** (api-auth 모듈):
  - 관리 테이블: providers, users, admins, refresh_tokens, email_verifications, user_history, admin_history
  - 설정: `api-auth-application.yml`에서 `module.aurora.schema=auth` 설정
- **archive 스키마** (api-archive 모듈):
  - 관리 테이블: archives, archive_history
  - 설정: `api-archive-application.yml`에서 `module.aurora.schema=archive` 설정
  - **주의사항**: `archives` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key를 지원하지 않으므로 애플리케이션 레벨에서 참조 무결성을 보장해야 함
- **chatbot 스키마** (api-chatbot 모듈):
  - 관리 테이블: conversation_sessions, conversation_messages
  - 설정: `api-chatbot-application.yml`에서 `module.aurora.schema=chatbot` 설정
  - **주의사항**: `conversation_sessions` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key를 지원하지 않으므로 애플리케이션 레벨에서 참조 무결성을 보장해야 함

### 스키마 매핑 설정 방식

각 API 모듈은 자체 `application.yml` 파일에서 `module.aurora.schema` 속성을 설정하고, `domain/aurora/src/main/resources/application-api-domain.yml`에서 `${module.aurora.schema}` 환경변수를 사용하여 동적으로 스키마를 참조합니다.

**설정 구조**:
1. 각 API 모듈의 `api-*-application.yml` 파일에서 `module.aurora.schema` 설정
2. `domain/aurora/src/main/resources/application-api-domain.yml`에서 `${module.aurora.schema}` 사용

**DataSource URL 형식**:
```yaml
spring:
  datasource:
    writer:
      url: jdbc:mysql://${AURORA_WRITER_ENDPOINT}:3306/${module.aurora.schema}?${AURORA_OPTIONS}
      username: ${AURORA_USERNAME}
      password: ${AURORA_PASSWORD}
    reader:
      url: jdbc:mysql://${AURORA_READER_ENDPOINT}:3306/${module.aurora.schema}?${AURORA_OPTIONS}
      username: ${AURORA_USERNAME}
      password: ${AURORA_PASSWORD}
```

**참고**: 스키마 매핑 설정 방식에 대한 상세 내용은 `docs/phase1/3. aurora-schema-design.md` 문서를 참고하세요.

### 공통 사항

모든 엔티티는 다음 공통 필드를 포함합니다:

- **Primary Key**: `id` (BIGINT UNSIGNED, TSID)
- **Soft Delete**: `is_deleted` (BOOLEAN, 기본값 FALSE), `deleted_at` (TIMESTAMP(6)), `deleted_by` (BIGINT UNSIGNED)
- **감사 필드**: `created_at`, `created_by`, `updated_at`, `updated_by`

### Provider 엔티티

OAuth 제공자 정보를 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| name | VARCHAR(50) | UNIQUE, NOT NULL | 제공자 이름 (예: "GOOGLE", "GITHUB") |
| display_name | VARCHAR(100) | NOT NULL | 표시 이름 |
| client_id | VARCHAR(255) | NULL | OAuth Client ID |
| client_secret | VARCHAR(500) | NULL | OAuth Client Secret (암호화) |
| is_enabled | BOOLEAN | NOT NULL DEFAULT TRUE | 활성화 여부 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `name` UNIQUE 인덱스
- `is_enabled` 인덱스
- `is_deleted` 인덱스

---

### User 엔티티

사용자 정보를 저장하는 엔티티입니다. MongoDB Atlas의 `UserProfileDocument`와 실시간 동기화됩니다.

**스키마**: `auth` (api-auth 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| email | VARCHAR(100) | UNIQUE, NOT NULL | 이메일 |
| username | VARCHAR(50) | UNIQUE, NOT NULL | 사용자명 |
| password | VARCHAR(255) | NULL | 비밀번호 해시 (OAuth 사용자 제외) |
| provider_id | BIGINT UNSIGNED | FOREIGN KEY, NULL | Provider 테이블 참조 |
| provider_user_id | VARCHAR(255) | NULL | OAuth 제공자의 사용자 ID |
| is_email_verified | BOOLEAN | NOT NULL DEFAULT FALSE | 이메일 인증 완료 여부 |
| last_login_at | TIMESTAMP(6) | NULL | 마지막 로그인 일시 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `email` UNIQUE 인덱스
- `username` UNIQUE 인덱스
- `provider_id` 외래 키 인덱스
- `provider_id + provider_user_id` 복합 인덱스
- `is_deleted` 인덱스

#### 동기화 전략

- **동기화 대상**: MongoDB Atlas `UserProfileDocument`
- **동기화 매핑**: `User.id(TSID)` → `UserProfileDocument.userTsid` (1:1 매핑)
- **Kafka 이벤트**:
  - `UserCreatedEvent`: User 엔티티 생성 시 발행 → UserProfileDocument 생성
  - `UserUpdatedEvent`: User 엔티티 수정 시 발행 → UserProfileDocument 업데이트
  - `UserDeletedEvent`: User 엔티티 Soft Delete 시 발행 → UserProfileDocument 물리적 삭제
  - `UserRestoredEvent`: User 엔티티 복원 시 발행 → UserProfileDocument 새로 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)

---

### Admin 엔티티

관리자 정보를 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| email | VARCHAR(100) | UNIQUE, NOT NULL | 이메일 |
| username | VARCHAR(50) | UNIQUE, NOT NULL | 사용자명 |
| password | VARCHAR(255) | NOT NULL | 비밀번호 해시 |
| role | VARCHAR(50) | NOT NULL | 역할 (예: "SUPER_ADMIN", "ADMIN") |
| is_active | BOOLEAN | NOT NULL DEFAULT TRUE | 활성화 여부 |
| last_login_at | TIMESTAMP(6) | NULL | 마지막 로그인 일시 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `email` UNIQUE 인덱스
- `username` UNIQUE 인덱스
- `role` 인덱스
- `is_active` 인덱스
- `is_deleted` 인덱스

---

### Archive 엔티티

사용자가 아카이브한 항목을 저장하는 엔티티입니다. MongoDB Atlas의 `ArchiveDocument`와 실시간 동기화됩니다.

**스키마**: `archive` (api-archive 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| user_id | BIGINT UNSIGNED | NOT NULL | auth 스키마의 users 테이블 참조 (스키마 간 Foreign Key 미지원) |
| item_type | VARCHAR(50) | NOT NULL | 항목 타입 (예: "CONTEST", "NEWS_ARTICLE") |
| item_id | VARCHAR(255) | NOT NULL | 항목 ID (MongoDB ObjectId 문자열) |
| tag | VARCHAR(100) | NULL | 태그 |
| memo | TEXT | NULL | 메모 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `user_id` 외래 키 인덱스
- `user_id + is_deleted` 복합 인덱스
- `user_id + item_type + item_id` UNIQUE 복합 인덱스 (중복 방지)

#### 제약조건

- `user_id + item_type + item_id` UNIQUE 제약조건 (Soft Delete 제외, 애플리케이션 레벨에서 처리)

#### 스키마 간 참조 주의사항

- **스키마 간 Foreign Key 제약조건**: `archives` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key 제약조건을 지원하지 않으므로, 애플리케이션 레벨에서 참조 무결성을 보장해야 합니다.
  - `user_id` 값의 유효성 검증은 애플리케이션 레벨에서 수행해야 합니다.
  - `users` 테이블의 레코드 삭제 시 관련 `archives` 레코드 처리도 애플리케이션 레벨에서 관리해야 합니다.

#### 동기화 전략

- **동기화 대상**: MongoDB Atlas `ArchiveDocument`
- **동기화 매핑**: `Archive.id(TSID)` → `ArchiveDocument.archiveTsid` (1:1 매핑)
- **Kafka 이벤트**:
  - `ArchiveCreatedEvent`: Archive 엔티티 생성 시 발행 → ArchiveDocument 생성
  - `ArchiveUpdatedEvent`: Archive 엔티티 수정 시 발행 → ArchiveDocument 업데이트
  - `ArchiveDeletedEvent`: Archive 엔티티 Soft Delete 시 발행 → ArchiveDocument 물리적 삭제
  - `ArchiveRestoredEvent`: Archive 엔티티 복원 시 발행 → ArchiveDocument 새로 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)

---

### RefreshToken 엔티티

JWT Refresh Token을 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| user_id | BIGINT UNSIGNED | FOREIGN KEY, NOT NULL | User 테이블 참조 |
| token | VARCHAR(500) | UNIQUE, NOT NULL | Refresh Token |
| expires_at | TIMESTAMP(6) | NOT NULL | 만료 일시 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NULL | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `token` UNIQUE 인덱스
- `user_id` 외래 키 인덱스
- `expires_at` 인덱스
- `is_deleted` 인덱스

---

### EmailVerification 엔티티

이메일 인증 정보를 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| email | VARCHAR(100) | NOT NULL | 인증 대상 이메일 |
| token | VARCHAR(255) | UNIQUE, NOT NULL | 인증 토큰 |
| type | VARCHAR(50) | NOT NULL | 토큰 타입 (예: "EMAIL_VERIFICATION", "PASSWORD_RESET") |
| expires_at | TIMESTAMP(6) | NOT NULL | 만료 일시 |
| verified_at | TIMESTAMP(6) | NULL | 인증 완료 일시 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NULL | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `token` UNIQUE 인덱스
- `email` 인덱스
- `email + type` 복합 인덱스 (동일 이메일의 여러 타입 토큰 구분용)
- `expires_at` 인덱스
- `is_deleted` 인덱스

---

### 히스토리 엔티티

모든 쓰기 작업에 대한 변경 이력을 추적하는 엔티티입니다.

#### UserHistory 엔티티

User 테이블의 변경 이력을 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

##### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| history_id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| user_id | BIGINT UNSIGNED | FOREIGN KEY, NOT NULL | User 테이블 참조 |
| operation_type | VARCHAR(20) | NOT NULL | 작업 타입 (INSERT, UPDATE, DELETE) |
| before_data | JSON | NULL | 변경 전 데이터 |
| after_data | JSON | NULL | 변경 후 데이터 |
| changed_by | BIGINT UNSIGNED | FOREIGN KEY, NULL | 변경한 사용자 ID |
| changed_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 변경 일시 |
| change_reason | VARCHAR(500) | NULL | 변경 사유 |

##### 인덱스

- `user_id` 외래 키 인덱스
- `changed_at` 인덱스
- `operation_type + changed_at` 복합 인덱스

#### AdminHistory 엔티티

Admin 테이블의 변경 이력을 저장하는 엔티티입니다.

**스키마**: `auth` (api-auth 모듈)

##### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| history_id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| admin_id | BIGINT UNSIGNED | FOREIGN KEY, NOT NULL | Admin 테이블 참조 |
| operation_type | VARCHAR(20) | NOT NULL | 작업 타입 (INSERT, UPDATE, DELETE) |
| before_data | JSON | NULL | 변경 전 데이터 |
| after_data | JSON | NULL | 변경 후 데이터 |
| changed_by | BIGINT UNSIGNED | FOREIGN KEY, NULL | 변경한 관리자 ID |
| changed_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 변경 일시 |
| change_reason | VARCHAR(500) | NULL | 변경 사유 |

##### 인덱스

- `admin_id` 외래 키 인덱스
- `changed_at` 인덱스
- `operation_type + changed_at` 복합 인덱스

#### ArchiveHistory 엔티티

Archive 테이블의 변경 이력을 저장하는 엔티티입니다.

**스키마**: `archive` (api-archive 모듈)

##### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| history_id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| archive_id | BIGINT UNSIGNED | FOREIGN KEY, NOT NULL | Archive 테이블 참조 |
| operation_type | VARCHAR(20) | NOT NULL | 작업 타입 (INSERT, UPDATE, DELETE) |
| before_data | JSON | NULL | 변경 전 데이터 |
| after_data | JSON | NULL | 변경 후 데이터 |
| changed_by | BIGINT UNSIGNED | FOREIGN KEY, NULL | 변경한 사용자 ID |
| changed_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 변경 일시 |
| change_reason | VARCHAR(500) | NULL | 변경 사유 |

##### 인덱스

- `archive_id` 외래 키 인덱스
- `changed_at` 인덱스
- `operation_type + changed_at` 복합 인덱스

**주의**: `operation_type='DELETE'`는 실제 SQL DELETE가 아닌 Soft Delete를 의미합니다.

---

### ConversationSession 엔티티

대화 세션 정보를 저장하는 엔티티입니다. MongoDB Atlas의 `ConversationSessionDocument`와 실시간 동기화됩니다.

**스키마**: `chatbot` (api-chatbot 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| session_id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| user_id | BIGINT UNSIGNED | NOT NULL | auth 스키마의 users 테이블 참조 (스키마 간 Foreign Key 미지원) |
| title | VARCHAR(200) | NULL | 세션 제목 (선택) |
| last_message_at | TIMESTAMP(6) | NOT NULL | 마지막 메시지 시간 |
| is_active | BOOLEAN | NOT NULL DEFAULT TRUE | 활성 세션 여부 |
| is_deleted | BOOLEAN | NOT NULL DEFAULT FALSE | 삭제 여부 |
| deleted_at | TIMESTAMP(6) | NULL | 삭제 일시 |
| deleted_by | BIGINT UNSIGNED | NULL | 삭제한 사용자 ID |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |
| created_by | BIGINT UNSIGNED | NULL | 생성한 사용자 ID |
| updated_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) | 수정 일시 |
| updated_by | BIGINT UNSIGNED | NULL | 수정한 사용자 ID |

#### 인덱스

- `session_id` PRIMARY KEY
- `user_id + is_active + last_message_at` 복합 인덱스 (사용자별 활성 세션 조회 최적화)

#### 스키마 간 참조 주의사항

- **스키마 간 Foreign Key 제약조건**: `conversation_sessions` 테이블의 `user_id`는 `auth` 스키마의 `users` 테이블을 참조하지만, MySQL은 스키마 간 Foreign Key 제약조건을 지원하지 않으므로, 애플리케이션 레벨에서 참조 무결성을 보장해야 합니다.
  - `user_id` 값의 유효성 검증은 애플리케이션 레벨에서 수행해야 합니다.
  - `users` 테이블의 레코드 삭제 시 관련 `conversation_sessions` 레코드 처리도 애플리케이션 레벨에서 관리해야 합니다.

#### 동기화 전략

- **동기화 대상**: MongoDB Atlas `ConversationSessionDocument`
- **동기화 매핑**: `ConversationSession.session_id(TSID)` → `ConversationSessionDocument.session_id` (1:1 매핑)
- **Kafka 이벤트**:
  - `ConversationSessionCreatedEvent`: ConversationSession 엔티티 생성 시 발행 → ConversationSessionDocument 생성
  - `ConversationSessionUpdatedEvent`: ConversationSession 엔티티 수정 시 발행 → ConversationSessionDocument 업데이트
  - `ConversationSessionDeletedEvent`: ConversationSession 엔티티 Soft Delete 시 발행 → ConversationSessionDocument 물리적 삭제
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)

---

### ConversationMessage 엔티티

대화 메시지 히스토리를 저장하는 엔티티입니다. MongoDB Atlas의 `ConversationMessageDocument`와 실시간 동기화됩니다.

**스키마**: `chatbot` (api-chatbot 모듈)

#### 필드 구조

| 필드명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| message_id | BIGINT UNSIGNED | PRIMARY KEY | TSID Primary Key |
| session_id | BIGINT UNSIGNED | FOREIGN KEY, NOT NULL | ConversationSession 테이블 참조 |
| role | VARCHAR(20) | NOT NULL | 메시지 역할 (USER, ASSISTANT, SYSTEM) |
| content | TEXT | NOT NULL | 메시지 내용 |
| token_count | INT | NULL | 토큰 수 (비용 계산용) |
| sequence_number | INT | NOT NULL | 대화 순서 (1부터 시작) |
| created_at | TIMESTAMP(6) | NOT NULL DEFAULT CURRENT_TIMESTAMP(6) | 생성 일시 |

#### 인덱스

- `message_id` PRIMARY KEY
- `session_id` 외래 키 인덱스
- `session_id + sequence_number` 복합 인덱스 (세션별 메시지 순서 조회 최적화)

#### Foreign Key

```sql
ALTER TABLE conversation_messages
ADD CONSTRAINT fk_message_session
FOREIGN KEY (session_id) REFERENCES conversation_sessions(session_id)
ON DELETE CASCADE;
```

#### 동기화 전략

- **동기화 대상**: MongoDB Atlas `ConversationMessageDocument`
- **동기화 매핑**: `ConversationMessage.message_id(TSID)` → `ConversationMessageDocument.message_id` (1:1 매핑)
- **Kafka 이벤트**:
  - `ConversationMessageCreatedEvent`: ConversationMessage 엔티티 생성 시 발행 → ConversationMessageDocument 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)

---

## Query Side 데이터 모델 (MongoDB Atlas)

Query Side는 읽기 전용으로 설계되었으며, 읽기 성능 최적화를 위해 비정규화된 구조를 사용합니다.

### 공통 사항

모든 도큐먼트는 다음 공통 필드를 포함합니다:

- **Primary Key**: `_id` (ObjectId)
- **감사 필드**: `createdAt`, `createdBy`, `updatedAt`, `updatedBy`
- **인덱스 전략**: ESR 규칙 (Equality → Sort → Range) 준수

### SourcesDocument

정보 출처 정보를 저장하는 도큐먼트입니다. `json/sources.json`의 데이터 구조를 기반으로 설계되었으며, `client-rss`와 `client-scraper` 모듈에서 데이터 수집 시 참조됩니다.

**데이터 수집 모듈 연관성**:
- **RSS 출처** (`type: "RSS"`): `client-rss` 모듈에서 RSS 피드 파싱을 통해 데이터 수집
  - `rssFeedUrl` 필드에 RSS 피드 URL 저장
  - `dataFormat` 필드는 "RSS/XML" 또는 "ATOM_1.0" 형식
  - 수집된 데이터는 `NewsArticleDocument`로 저장
- **Web Scraping 출처** (`type: "Web Scraping"`): `client-scraper` 모듈에서 웹 스크래핑을 통해 데이터 수집
  - `url` 필드에 스크래핑 대상 URL 저장
  - `dataFormat` 필드는 "HTML" 또는 "GraphQL" 형식
  - 수집된 데이터는 `ContestDocument` 또는 `NewsArticleDocument`로 저장
- **API 출처** (`type: "API"`): API 호출을 통해 데이터 수집 (별도 모듈)
  - `apiEndpoint` 필드에 API 엔드포인트 URL 저장
  - `dataFormat` 필드는 "JSON" 형식

**상세 설계**: RSS/Scraper 모듈의 구현 상세는 `docs/step8/rss-scraper-modules-analysis.md` 문서를 참고하세요.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  name: String,                     // 출처 이름 (UNIQUE)
  type: String,                     // 출처 타입: "API", "RSS", "Web Scraping"
  category: String,                 // 카테고리: "개발자 대회 정보", "최신 IT 테크 뉴스 정보"
  url: String,                      // 출처 URL
  apiEndpoint: String,              // API 엔드포인트 (nullable)
  rssFeedUrl: String,               // RSS 피드 URL (nullable)
  description: String,              // 설명
  priority: Integer,                // 우선순위: 1, 2, 3
  reliabilityScore: Integer,        // 신뢰성 점수 (0-10)
  accessibilityScore: Integer,       // 접근성 점수 (0-10)
  dataQualityScore: Integer,        // 데이터 품질 점수 (0-10)
  legalEthicalScore: Integer,       // 법적/윤리적 점수 (0-10)
  totalScore: Integer,              // 총점
  authenticationRequired: Boolean,   // 인증 필요 여부
  authenticationMethod: String,      // 인증 방법: "None", "API Key", "OAuth"
  rateLimit: String,                 // Rate limit 정보
  documentationUrl: String,          // 문서 URL
  updateFrequency: String,           // 업데이트 빈도: "실시간", "일일", "주간"
  dataFormat: String,                // 데이터 형식: "JSON", "RSS/XML", "HTML"
  enabled: Boolean,                  // 활성화 여부
  createdAt: Date,                   // 생성 일시
  createdBy: String,                 // 생성자 ID (nullable)
  updatedAt: Date,                   // 수정 일시
  updatedBy: String                  // 수정자 ID (nullable)
}
```

#### 인덱스

- `name` UNIQUE 인덱스
- `type + enabled` 복합 인덱스
- `priority` 단일 인덱스

---

### ContestDocument

개발자 대회 정보를 저장하는 도큐먼트입니다. 읽기 최적화를 위해 비정규화된 구조를 사용합니다.

**데이터 수집**: `client-scraper` 모듈에서 웹 스크래핑을 통해 수집된 대회 정보가 이 도큐먼트로 저장됩니다. `sourceId` 필드를 통해 `SourcesDocument`를 참조하며, `metadata.sourceName` 필드에 출처 이름이 비정규화되어 저장됩니다.

**상세 설계**: 웹 스크래핑 모듈의 구현 상세는 `docs/step8/rss-scraper-modules-analysis.md` 문서를 참고하세요.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  sourceId: ObjectId,               // SourcesDocument 참조 (FK)
  title: String,                    // 대회 제목
  startDate: Date,                  // 시작 일시
  endDate: Date,                    // 종료 일시
  status: String,                   // 상태: "UPCOMING", "ONGOING", "ENDED"
  description: String,              // 설명
  url: String,                      // 대회 URL
  metadata: {                        // 비정규화된 메타데이터
    sourceName: String,             // 출처 이름 (비정규화)
    prize: String,                  // 상금 정보 (nullable)
    participants: Integer,          // 참가자 수 (nullable)
    tags: [String]                  // 태그 배열
  },
  createdAt: Date,                   // 생성 일시
  createdBy: String,                 // 생성자 ID (nullable)
  updatedAt: Date,                  // 수정 일시
  updatedBy: String                 // 수정자 ID (nullable)
}
```

#### 인덱스

- `sourceId + startDate` 복합 인덱스 (ESR 규칙: E, S)
- `endDate` 단일 인덱스
- `status + startDate` 복합 인덱스 (부분 인덱스, UPCOMING/ONGOING만)
- `sourceId` 외래 키 인덱스

#### 비정규화

- `metadata.sourceName`: 출처 이름 중복 저장 (SourcesDocument 조인 불필요)

---

### NewsArticleDocument

IT 테크 뉴스 기사를 저장하는 도큐먼트입니다. 읽기 최적화를 위해 비정규화된 구조를 사용합니다.

**데이터 수집**: `client-rss` 모듈에서 RSS 피드 파싱을 통해 수집된 뉴스 기사가 이 도큐먼트로 저장됩니다. `sourceId` 필드를 통해 `SourcesDocument`를 참조하며, `metadata.sourceName` 필드에 출처 이름이 비정규화되어 저장됩니다.

**상세 설계**: RSS 피드 파싱 모듈의 구현 상세는 `docs/step8/rss-scraper-modules-analysis.md` 문서를 참고하세요.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  sourceId: ObjectId,               // SourcesDocument 참조 (FK)
  title: String,                    // 기사 제목
  content: String,                  // 기사 내용 (전체 텍스트)
  summary: String,                  // 요약 (비정규화)
  publishedAt: Date,                // 발행 일시
  url: String,                      // 기사 URL
  author: String,                   // 작성자 (nullable)
  metadata: {                        // 비정규화된 메타데이터
    sourceName: String,             // 출처 이름 (비정규화)
    tags: [String],                 // 태그 배열
    viewCount: Integer,             // 조회수 (nullable)
    likeCount: Integer              // 좋아요 수 (nullable)
  },
  createdAt: Date,                  // 생성 일시
  createdBy: String,                // 생성자 ID (nullable)
  updatedAt: Date,                   // 수정 일시
  updatedBy: String                 // 수정자 ID (nullable)
}
```

#### 인덱스

- `sourceId + publishedAt` 복합 인덱스 (ESR 규칙: E, S)
- `publishedAt` TTL 인덱스 (90일 후 자동 삭제)
- `sourceId` 외래 키 인덱스

#### 비정규화

- `metadata.sourceName`: 출처 이름 중복 저장 (SourcesDocument 조인 불필요)

---

### ArchiveDocument

사용자가 아카이브한 항목을 저장하는 도큐먼트입니다. Aurora MySQL의 `Archive` 엔티티와 실시간 동기화됩니다.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  archiveTsid: String,              // Aurora MySQL Archive 테이블 TSID PK 값 (BIGINT UNSIGNED, UNIQUE)
  userId: String,                   // 사용자 ID (Command Side의 User 테이블 참조)
  itemType: String,                 // 항목 타입: "CONTEST", "NEWS_ARTICLE"
  itemId: ObjectId,                 // 항목 ID (ContestDocument 또는 NewsArticleDocument 참조)
  itemTitle: String,                // 항목 제목 (비정규화)
  itemSummary: String,              // 항목 요약 (비정규화)
  tag: String,                      // 태그 (nullable)
  memo: String,                     // 메모 (nullable)
  archivedAt: Date,                 // 아카이브 일시
  createdAt: Date,                  // 생성 일시
  createdBy: String,                // 생성자 ID (nullable)
  updatedAt: Date,                  // 수정 일시
  updatedBy: String                 // 수정자 ID (nullable)
}
```

#### 인덱스

- `archiveTsid` UNIQUE 인덱스 (Aurora MySQL 동기화용)
- `userId + createdAt` 복합 인덱스 (ESR 규칙: E, S)
- `userId + itemType + createdAt` 복합 인덱스 (ESR 규칙: E, E, S)
- `userId + itemType + itemId` UNIQUE 복합 인덱스 (중복 방지)

#### 비정규화

- `itemTitle`, `itemSummary`: 항목 제목/요약 중복 저장 (ContestDocument/NewsArticleDocument 조인 불필요)

#### 동기화 전략

- **동기화 대상**: Aurora MySQL `Archive` 엔티티
- **동기화 매핑**: `Archive.id(TSID)` → `ArchiveDocument.archiveTsid` (1:1 매핑)
- **Kafka 이벤트**:
  - `ArchiveCreatedEvent`: Archive 엔티티 생성 시 발행 → ArchiveDocument 생성
  - `ArchiveUpdatedEvent`: Archive 엔티티 수정 시 발행 → ArchiveDocument 업데이트
    - **주의**: `updatedFields`에는 `tag`, `memo`만 포함 가능 (ArchiveEntity에 있는 필드만)
    - `itemTitle`, `itemSummary`는 ArchiveEntity에 없는 필드이므로 `updatedFields`에 포함될 수 없음
    - 원본 아이템 변경 시 별도의 동기화 메커니즘으로 `ArchiveDocument`의 `itemTitle`, `itemSummary`를 업데이트해야 함
  - `ArchiveDeletedEvent`: Archive 엔티티 Soft Delete 시 발행 → ArchiveDocument 물리적 삭제
  - `ArchiveRestoredEvent`: Archive 엔티티 복원 시 발행 → ArchiveDocument 새로 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)
- **MongoDB Soft Delete 미지원**: Soft Delete 시 Document 물리적 삭제, 복원 시 Document 새로 생성

---

### UserProfileDocument

사용자 프로필 정보를 저장하는 도큐먼트입니다. Aurora MySQL의 `User` 엔티티와 실시간 동기화됩니다.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  userTsid: String,                 // Aurora MySQL User 테이블 TSID PK 값 (BIGINT UNSIGNED, UNIQUE)
  userId: String,                   // 사용자 ID (UNIQUE, Command Side의 User 테이블 참조)
  username: String,                // 사용자명 (UNIQUE)
  email: String,                   // 이메일 (UNIQUE)
  profileImageUrl: String,         // 프로필 이미지 URL (nullable)
  createdAt: Date,                 // 생성 일시
  createdBy: String,               // 생성자 ID (nullable)
  updatedAt: Date,                 // 수정 일시
  updatedBy: String                // 수정자 ID (nullable)
}
```

#### 인덱스

- `userTsid` UNIQUE 인덱스 (Aurora MySQL 동기화용)
- `userId` UNIQUE 인덱스
- `username` UNIQUE 인덱스
- `email` UNIQUE 인덱스

#### 동기화 전략

- **동기화 대상**: Aurora MySQL `User` 엔티티
- **동기화 매핑**: `User.id(TSID)` → `UserProfileDocument.userTsid` (1:1 매핑)
- **Kafka 이벤트**:
  - `UserCreatedEvent`: User 엔티티 생성 시 발행 → UserProfileDocument 생성
  - `UserUpdatedEvent`: User 엔티티 수정 시 발행 → UserProfileDocument 업데이트
  - `UserDeletedEvent`: User 엔티티 Soft Delete 시 발행 → UserProfileDocument 물리적 삭제
  - `UserRestoredEvent`: User 엔티티 복원 시 발행 → UserProfileDocument 새로 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)
- **MongoDB Soft Delete 미지원**: Soft Delete 시 Document 물리적 삭제, 복원 시 Document 새로 생성

---

### ConversationSessionDocument

대화 세션 정보를 저장하는 도큐먼트입니다. Aurora MySQL의 `ConversationSession` 엔티티와 실시간 동기화됩니다.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  session_id: String,               // Aurora MySQL ConversationSession 테이블 TSID PK 값 (BIGINT UNSIGNED, UNIQUE)
  user_id: String,                  // 사용자 ID (Command Side의 User 테이블 참조)
  title: String,                    // 세션 제목 (nullable)
  last_message_at: Date,            // 마지막 메시지 시간
  is_active: Boolean,               // 활성 세션 여부
  created_at: Date,                 // 생성 일시
  updated_at: Date                  // 수정 일시
}
```

#### 인덱스

- `session_id` UNIQUE 인덱스 (Aurora MySQL 동기화용)
- `user_id + is_active + last_message_at` 복합 인덱스 (ESR 규칙: E, E, S)
- `last_message_at` TTL 인덱스 (90일 후 자동 삭제)

#### 동기화 전략

- **동기화 대상**: Aurora MySQL `ConversationSession` 엔티티
- **동기화 매핑**: `ConversationSession.session_id(TSID)` → `ConversationSessionDocument.session_id` (1:1 매핑)
- **Kafka 이벤트**:
  - `ConversationSessionCreatedEvent`: ConversationSession 엔티티 생성 시 발행 → ConversationSessionDocument 생성
  - `ConversationSessionUpdatedEvent`: ConversationSession 엔티티 수정 시 발행 → ConversationSessionDocument 업데이트
  - `ConversationSessionDeletedEvent`: ConversationSession 엔티티 Soft Delete 시 발행 → ConversationSessionDocument 물리적 삭제
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)
- **MongoDB Soft Delete 미지원**: Soft Delete 시 Document 물리적 삭제

---

### ConversationMessageDocument

대화 메시지 히스토리를 저장하는 도큐먼트입니다. Aurora MySQL의 `ConversationMessage` 엔티티와 실시간 동기화됩니다.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  message_id: String,               // Aurora MySQL ConversationMessage 테이블 TSID PK 값 (BIGINT UNSIGNED, UNIQUE)
  session_id: String,               // 세션 ID (ConversationSessionDocument 참조)
  role: String,                    // 메시지 역할: "USER", "ASSISTANT", "SYSTEM"
  content: String,                  // 메시지 내용
  token_count: Integer,             // 토큰 수 (nullable)
  sequence_number: Integer,        // 대화 순서 (1부터 시작)
  created_at: Date                 // 생성 일시
}
```

#### 인덱스

- `message_id` UNIQUE 인덱스 (Aurora MySQL 동기화용)
- `session_id + sequence_number` 복합 인덱스 (ESR 규칙: E, S)
- `created_at` TTL 인덱스 (1년 후 자동 삭제)

#### 동기화 전략

- **동기화 대상**: Aurora MySQL `ConversationMessage` 엔티티
- **동기화 매핑**: `ConversationMessage.message_id(TSID)` → `ConversationMessageDocument.message_id` (1:1 매핑)
- **Kafka 이벤트**:
  - `ConversationMessageCreatedEvent`: ConversationMessage 엔티티 생성 시 발행 → ConversationMessageDocument 생성
- **동기화 지연 시간**: 실시간 동기화 목표 (1초 이내)

---

### ExceptionLogDocument

예외 로그를 저장하는 도큐먼트입니다. 읽기/쓰기 예외를 모두 기록합니다.

#### 필드 구조

```javascript
{
  _id: ObjectId,                    // MongoDB 자동 생성
  source: String,                   // 예외 소스: "READ", "WRITE"
  exceptionType: String,            // 예외 타입 (예: "DataAccessException", "ValidationException")
  exceptionMessage: String,         // 예외 메시지
  stackTrace: String,               // 스택 트레이스 (전체)
  context: {                         // 컨텍스트 정보 (Object)
    module: String,                 // 모듈명
    method: String,                 // 메서드명
    parameters: Object,             // 파라미터 정보
    userId: String,                 // 사용자 ID (nullable)
    requestId: String               // 요청 ID (nullable)
  },
  occurredAt: Date,                  // 발생 일시
  severity: String,                  // 심각도: "LOW", "MEDIUM", "HIGH", "CRITICAL"
  createdAt: Date,                   // 생성 일시
  createdBy: String,                 // 생성자 ID (nullable)
  updatedAt: Date,                  // 수정 일시
  updatedBy: String                 // 수정자 ID (nullable)
}
```

#### 인덱스

- `source + occurredAt` 복합 인덱스 (ESR 규칙: E, S)
- `exceptionType + occurredAt` 복합 인덱스 (ESR 규칙: E, S)
- `occurredAt` TTL 인덱스 (90일 후 자동 삭제)

---

## 실시간 동기화 전략

### 동기화 원칙

1. **이벤트 기반 동기화**: 모든 쓰기 작업 후 Kafka 이벤트 발행
2. **TSID 필드 기반 매핑**: 1:1 매핑으로 동기화 정확성 보장
3. **실시간 동기화**: 동기화 지연 시간 1초 이내 목표
4. **MongoDB Soft Delete 미지원**: Soft Delete 시 Document 물리적 삭제, 복원 시 Document 새로 생성

### User 엔티티 → UserProfileDocument 동기화

#### 동기화 흐름

1. **User 엔티티 생성**:
   - Aurora MySQL `User` 엔티티 생성
   - `UserHistory` 엔티티 생성 (operation_type: INSERT)
   - **Kafka 이벤트 발행**: `UserCreatedEvent`
     - 페이로드: `userTsid` (User.id), `userId`, `username`, `email`, `profileImageUrl` 등
   - MongoDB Atlas `UserProfileDocument` 생성 (userTsid 필드 활용)

2. **User 엔티티 수정**:
   - Aurora MySQL `User` 엔티티 업데이트
   - `UserHistory` 엔티티 생성 (operation_type: UPDATE)
   - **Kafka 이벤트 발행**: `UserUpdatedEvent`
     - 페이로드: `userTsid`, 변경된 필드 정보 포함
   - MongoDB Atlas `UserProfileDocument` 업데이트 (userTsid 필드 활용)

3. **User 엔티티 Soft Delete**:
   - Aurora MySQL `User` 엔티티 Soft Delete (is_deleted=TRUE, deleted_at 설정)
   - `UserHistory` 엔티티 생성 (operation_type: DELETE)
   - **Kafka 이벤트 발행**: `UserDeletedEvent`
     - 페이로드: `userTsid`, `userId`, `deletedAt` 등
   - MongoDB Atlas `UserProfileDocument` 물리적 삭제 (MongoDB는 Soft Delete 미지원)

4. **User 엔티티 복원**:
   - Aurora MySQL `User` 엔티티 복원 (is_deleted=FALSE, deleted_at=null)
   - `UserHistory` 엔티티 생성 (operation_type: UPDATE)
   - **Kafka 이벤트 발행**: `UserRestoredEvent`
     - 페이로드: `userTsid`, `userId`, `username`, `email`, `profileImageUrl` 등
   - MongoDB Atlas `UserProfileDocument` 새로 생성 (MongoDB는 Soft Delete 미지원이므로 복원 시 재생성 필요)

#### 동기화 매핑

- `User.id(TSID)` → `UserProfileDocument.userTsid` (1:1 매핑)
- `userTsid` 필드를 통해 정확한 동기화 보장

#### 동기화 지연 시간

- 목표: 1초 이내
- Kafka 이벤트 발행 후 즉시 MongoDB Atlas 동기화

---

### ConversationSession 엔티티 → ConversationSessionDocument 동기화

#### 동기화 흐름

1. **ConversationSession 엔티티 생성**:
   - Aurora MySQL `ConversationSession` 엔티티 생성
   - **Kafka 이벤트 발행**: `ConversationSessionCreatedEvent`
     - 페이로드: `sessionId` (ConversationSession.session_id), `userId`, `title`, `lastMessageAt`, `isActive` 등
   - MongoDB Atlas `ConversationSessionDocument` 생성 (session_id 필드 활용)

2. **ConversationSession 엔티티 수정**:
   - Aurora MySQL `ConversationSession` 엔티티 업데이트
   - **Kafka 이벤트 발행**: `ConversationSessionUpdatedEvent`
     - 페이로드: `sessionId`, 변경된 필드 정보 포함
   - MongoDB Atlas `ConversationSessionDocument` 업데이트 (session_id 필드 활용)

3. **ConversationSession 엔티티 Soft Delete**:
   - Aurora MySQL `ConversationSession` 엔티티 Soft Delete (is_deleted=TRUE, deleted_at 설정)
   - **Kafka 이벤트 발행**: `ConversationSessionDeletedEvent`
     - 페이로드: `sessionId`, `userId`, `deletedAt` 등
   - MongoDB Atlas `ConversationSessionDocument` 물리적 삭제 (MongoDB는 Soft Delete 미지원)

#### 동기화 매핑

- `ConversationSession.session_id(TSID)` → `ConversationSessionDocument.session_id` (1:1 매핑)
- `session_id` 필드를 통해 정확한 동기화 보장

#### 동기화 지연 시간

- 목표: 1초 이내
- Kafka 이벤트 발행 후 즉시 MongoDB Atlas 동기화

---

### ConversationMessage 엔티티 → ConversationMessageDocument 동기화

#### 동기화 흐름

1. **ConversationMessage 엔티티 생성**:
   - Aurora MySQL `ConversationMessage` 엔티티 생성
   - **Kafka 이벤트 발행**: `ConversationMessageCreatedEvent`
     - 페이로드: `messageId` (ConversationMessage.message_id), `sessionId`, `role`, `content`, `tokenCount`, `sequenceNumber` 등
   - MongoDB Atlas `ConversationMessageDocument` 생성 (message_id 필드 활용)

#### 동기화 매핑

- `ConversationMessage.message_id(TSID)` → `ConversationMessageDocument.message_id` (1:1 매핑)
- `message_id` 필드를 통해 정확한 동기화 보장

#### 동기화 지연 시간

- 목표: 1초 이내
- Kafka 이벤트 발행 후 즉시 MongoDB Atlas 동기화

---

### Archive 엔티티 → ArchiveDocument 동기화

#### 동기화 흐름

1. **Archive 엔티티 생성**:
   - Aurora MySQL `Archive` 엔티티 생성
   - `ArchiveHistory` 엔티티 생성 (operation_type: INSERT)
   - **Kafka 이벤트 발행**: `ArchiveCreatedEvent`
     - 페이로드: `archiveTsid` (Archive.id), `userId`, `itemType`, `itemId`, `tag`, `memo` 등
   - MongoDB Atlas `ArchiveDocument` 생성 (archiveTsid 필드 활용)

2. **Archive 엔티티 수정**:
   - Aurora MySQL `Archive` 엔티티 업데이트
   - `ArchiveHistory` 엔티티 생성 (operation_type: UPDATE)
   - **Kafka 이벤트 발행**: `ArchiveUpdatedEvent`
     - 페이로드: `archiveTsid`, 변경된 필드 정보 포함
   - MongoDB Atlas `ArchiveDocument` 업데이트 (archiveTsid 필드 활용)

3. **Archive 엔티티 Soft Delete**:
   - Aurora MySQL `Archive` 엔티티 Soft Delete (is_deleted=TRUE, deleted_at 설정)
   - `ArchiveHistory` 엔티티 생성 (operation_type: DELETE)
   - **Kafka 이벤트 발행**: `ArchiveDeletedEvent`
     - 페이로드: `archiveTsid`, `userId`, `deletedAt` 등
   - MongoDB Atlas `ArchiveDocument` 물리적 삭제 (MongoDB는 Soft Delete 미지원)

4. **Archive 엔티티 복원**:
   - Aurora MySQL `Archive` 엔티티 복원 (is_deleted=FALSE, deleted_at=null)
   - `ArchiveHistory` 엔티티 생성 (operation_type: UPDATE)
   - **Kafka 이벤트 발행**: `ArchiveRestoredEvent`
     - 페이로드: `archiveTsid`, `userId`, `itemType`, `itemId`, `tag`, `memo` 등
   - MongoDB Atlas `ArchiveDocument` 새로 생성 (MongoDB는 Soft Delete 미지원이므로 복원 시 재생성 필요)

#### 동기화 매핑

- `Archive.id(TSID)` → `ArchiveDocument.archiveTsid` (1:1 매핑)
- `archiveTsid` 필드를 통해 정확한 동기화 보장

#### 동기화 지연 시간

- 목표: 1초 이내
- Kafka 이벤트 발행 후 즉시 MongoDB Atlas 동기화

---

### Kafka 이벤트 설계

#### 이벤트 공통 구조

```json
{
  "eventId": "event-uuid",
  "eventType": "UserCreatedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    // 이벤트별 페이로드
  }
}
```

#### UserCreatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "UserCreatedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "userTsid": "9876543210987654321",
    "userId": "user123",
    "username": "john_doe",
    "email": "john@example.com",
    "profileImageUrl": "https://example.com/avatars/john.jpg"
  }
}
```

#### UserUpdatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "UserUpdatedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "userTsid": "9876543210987654321",
    "userId": "user123",
    "updatedFields": {
      "username": "updated_john_doe",
      "profileImageUrl": "https://example.com/avatars/updated_john.jpg"
    }
  }
}
```

#### UserDeletedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "UserDeletedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "userTsid": "9876543210987654321",
    "userId": "user123",
    "deletedAt": "2026-01-07T10:00:00Z"
  }
}
```

#### UserRestoredEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "UserRestoredEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "userTsid": "9876543210987654321",
    "userId": "user123",
    "username": "john_doe",
    "email": "john@example.com",
    "profileImageUrl": "https://example.com/avatars/john.jpg"
  }
}
```

#### ArchiveCreatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ArchiveCreatedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "archiveTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "itemTitle": "Codeforces Round 900",
    "itemSummary": "Regular Codeforces contest",
    "tag": "algorithm",
    "memo": "참가 예정",
    "archivedAt": "2026-01-07T10:00:00Z"
  }
}
```

#### ArchiveUpdatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ArchiveUpdatedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "archiveTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "updatedFields": {
      "tag": "updated-algorithm",
      "memo": "수정된 메모"
    }
  }
}
```

#### ArchiveDeletedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ArchiveDeletedEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "archiveTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "deletedAt": "2026-01-08T10:00:00Z"
  }
}
```

#### ArchiveRestoredEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ArchiveRestoredEvent",
  "timestamp": "2026-01-07T10:00:00Z",
  "payload": {
    "archiveTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "itemTitle": "Codeforces Round 900",
    "itemSummary": "Regular Codeforces contest",
    "tag": "algorithm",
    "memo": "참가 예정",
    "archivedAt": "2026-01-07T10:00:00Z"
  }
}
```

#### ConversationSessionCreatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ConversationSessionCreatedEvent",
  "timestamp": "2026-01-16T10:00:00Z",
  "payload": {
    "sessionId": "1234567890123456789",
    "userId": "9876543210987654321",
    "title": "대화 세션 제목",
    "lastMessageAt": "2026-01-16T10:00:00Z",
    "isActive": true
  }
}
```

#### ConversationSessionUpdatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ConversationSessionUpdatedEvent",
  "timestamp": "2026-01-16T10:00:00Z",
  "payload": {
    "sessionId": "1234567890123456789",
    "updatedFields": {
      "title": "수정된 세션 제목",
      "lastMessageAt": "2026-01-16T11:00:00Z",
      "isActive": true
    }
  }
}
```

#### ConversationSessionDeletedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ConversationSessionDeletedEvent",
  "timestamp": "2026-01-16T10:00:00Z",
  "payload": {
    "sessionId": "1234567890123456789",
    "userId": "9876543210987654321",
    "deletedAt": "2026-01-16T10:00:00Z"
  }
}
```

#### ConversationMessageCreatedEvent

```json
{
  "eventId": "event-uuid",
  "eventType": "ConversationMessageCreatedEvent",
  "timestamp": "2026-01-16T10:00:00Z",
  "payload": {
    "messageId": "2345678901234567890",
    "sessionId": "1234567890123456789",
    "role": "USER",
    "content": "사용자 메시지 내용",
    "tokenCount": 50,
    "sequenceNumber": 1
  }
}
```

---

### 동기화 보장 전략

#### 멱등성 보장

- 이벤트 ID 기반 중복 처리 방지
- 동일한 이벤트 ID로 여러 번 수신되어도 한 번만 처리

#### 순서 보장

- Partition Key를 `userId` 또는 `archiveTsid`로 설정하여 사용자별/아카이브별 순서 보장
- 동일한 사용자/아카이브의 이벤트는 순서대로 처리

#### 트랜잭션 관리

- DB 커밋 후 Kafka 이벤트 발행 (트랜잭션 아웃박스 패턴 고려)
- 이벤트 발행 실패 시 재시도 로직

#### TSID 필드 기반 매핑

- `userTsid`, `archiveTsid`, `session_id`, `message_id` 필드를 통해 정확한 1:1 매핑 보장
- 동기화 실패 시 재시도 로직 실행 (최대 3회)
- 재시도 실패 시 Dead Letter Queue 처리

#### 동기화 상태 모니터링

- 동기화 지연 시간 모니터링
- 동기화 실패율 모니터링
- 알림 및 경고 설정

---

## TSID 필드 기반 매핑

### 매핑 전략

Command Side의 TSID Primary Key를 Query Side의 UNIQUE 필드로 매핑하여 1:1 관계를 보장합니다.

### User → UserProfileDocument 매핑

- **Command Side**: `User.id` (BIGINT UNSIGNED, TSID)
- **Query Side**: `UserProfileDocument.userTsid` (String, UNIQUE)
- **매핑 방식**: `User.id` 값을 문자열로 변환하여 `UserProfileDocument.userTsid`에 저장
- **동기화 확인**: `userTsid` 필드로 정확한 매핑 확인

### Archive → ArchiveDocument 매핑

- **Command Side**: `Archive.id` (BIGINT UNSIGNED, TSID)
- **Query Side**: `ArchiveDocument.archiveTsid` (String, UNIQUE)
- **매핑 방식**: `Archive.id` 값을 문자열로 변환하여 `ArchiveDocument.archiveTsid`에 저장
- **동기화 확인**: `archiveTsid` 필드로 정확한 매핑 확인

### ConversationSession → ConversationSessionDocument 매핑

- **Command Side**: `ConversationSession.session_id` (BIGINT UNSIGNED, TSID)
- **Query Side**: `ConversationSessionDocument.session_id` (String, UNIQUE)
- **매핑 방식**: `ConversationSession.session_id` 값을 문자열로 변환하여 `ConversationSessionDocument.session_id`에 저장
- **동기화 확인**: `session_id` 필드로 정확한 매핑 확인

### ConversationMessage → ConversationMessageDocument 매핑

- **Command Side**: `ConversationMessage.message_id` (BIGINT UNSIGNED, TSID)
- **Query Side**: `ConversationMessageDocument.message_id` (String, UNIQUE)
- **매핑 방식**: `ConversationMessage.message_id` 값을 문자열로 변환하여 `ConversationMessageDocument.message_id`에 저장
- **동기화 확인**: `message_id` 필드로 정확한 매핑 확인

### 매핑 장점

1. **정확성**: TSID 필드 기반 1:1 매핑으로 동기화 정확성 보장
2. **성능**: UNIQUE 인덱스로 빠른 조회 가능
3. **추적성**: 동기화 상태를 쉽게 확인 가능
4. **복구**: 동기화 실패 시 재시도 가능

---

## 결론

이 설계서는 CQRS 패턴을 기반으로 한 데이터 모델 설계를 제공합니다. Command Side는 쓰기 최적화를 위해 높은 정규화 수준을 유지하고, Query Side는 읽기 최적화를 위해 비정규화된 구조를 사용합니다. Kafka 이벤트 기반 실시간 동기화를 통해 데이터 일관성을 보장합니다.

### 주요 특징

1. ✅ **CQRS 패턴 적용**: Command Side와 Query Side 명확히 분리
2. ✅ **TSID Primary Key**: 모든 Command Side 엔티티에 TSID 적용
3. ✅ **Soft Delete**: Command Side에서 Soft Delete 구현
4. ✅ **비정규화**: Query Side에서 읽기 최적화를 위한 비정규화
5. ✅ **실시간 동기화**: Kafka 이벤트 기반 1초 이내 동기화 목표
6. ✅ **TSID 필드 기반 매핑**: 1:1 매핑으로 동기화 정확성 보장

### 다음 단계

1. JPA Entity 클래스 생성 (Command Side)
2. MongoDB Document 클래스 생성 (Query Side)
3. Repository 인터페이스 생성
4. Kafka 이벤트 발행 로직 구현
5. MongoDB Atlas 동기화 컨슈머 구현
6. 동기화 모니터링 시스템 구축

---

**문서 버전**: 1.1  
**최종 업데이트**: 2026-01-16  
**작성자**: Data Model Architect

### 변경 이력

- **v1.1 (2026-01-16)**: 
  - `ConversationSession` 엔티티 추가 (RAG 챗봇 대화 세션 관리)
  - `ConversationMessage` 엔티티 추가 (RAG 챗봇 대화 메시지 히스토리)
  - `ConversationSessionDocument` 추가 (MongoDB Atlas)
  - `ConversationMessageDocument` 추가 (MongoDB Atlas)
  - 관련 Kafka 이벤트 및 동기화 전략 추가
  - TSID 필드 기반 매핑 전략 확장
- **v1.0 (2026-01-07)**: 초기 버전

