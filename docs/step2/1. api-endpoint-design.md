# RESTful API 엔드포인트 설계서

**작성 일시**: 2026-01-07  
**대상**: API Server 엔드포인트 설계  
**아키텍처**: CQRS 패턴 기반 (Command Side: Aurora MySQL, Query Side: MongoDB Atlas)

## 목차

1. [개요](#개요)
2. [공개 API 엔드포인트](#공개-api-엔드포인트)
3. [사용자 북마크 API 엔드포인트](#사용자-북마크-api-엔드포인트)
4. [인증 API 엔드포인트](#인증-api-엔드포인트)
5. [챗봇 API 엔드포인트](#챗봇-api-엔드포인트)
6. [CQRS 패턴 적용](#cqrs-패턴-적용)
7. [Kafka 이벤트 발행 전략](#kafka-이벤트-발행-전략)

---

## 개요

이 설계서는 CQRS 패턴을 기반으로 한 RESTful API 엔드포인트 설계를 다룹니다. 모든 읽기 작업은 MongoDB Atlas(Query Side)에서, 모든 쓰기 작업은 Aurora MySQL(Command Side)에서 수행됩니다.

### API 모듈 구성

이 설계서는 다음 API 모듈들의 엔드포인트를 다룹니다:

- **api-bookmark**: 사용자 북마크 관리 API (Aurora MySQL 사용, `bookmark` 스키마)
  - `api-bookmark-application.yml`에서 `module.aurora.schema=bookmark` 설정
  - `application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적 연결
- **api-auth**: 인증 및 사용자 관리 API (Aurora MySQL 사용, `auth` 스키마)
  - `api-auth-application.yml`에서 `module.aurora.schema=auth` 설정
  - `application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적 연결
- **api-chatbot**: RAG 기반 챗봇 API (MongoDB Atlas + Aurora MySQL 사용)
  - RAG 검색: MongoDB Atlas Vector Search 사용 (EmergingTechDocument)
  - 세션 및 메시지 저장: Aurora MySQL 사용
  - 상세 설계: `docs/step12/rag-chatbot-design.md` 문서 참고

### 설계 원칙

1. **RESTful 원칙 준수**: HTTP 메서드와 상태 코드를 적절히 사용
2. **CQRS 패턴 적용**: 읽기/쓰기 엔드포인트 명확히 분리
3. **인증 및 권한**: JWT 토큰 기반 인증, 사용자별 데이터 타게팅
4. **이벤트 기반 동기화**: 모든 쓰기 작업 후 Kafka 이벤트 발행
5. **Soft Delete 지원**: 삭제 작업은 Soft Delete로 처리 (Aurora MySQL만)

### API 버전 관리

- **Base URL**: `/api/v1`
- **버전 관리**: URL 경로에 버전 포함 (`/api/v1/...`)

---

## 공개 API 엔드포인트

인증 없이 접근 가능한 공개 API입니다. 모든 읽기 작업은 MongoDB Atlas에서 수행됩니다.

> Contest/News 수집 기능 폐기로 출처 API, 대회 API (api-contest), 뉴스 API (api-news) 엔드포인트 섹션 삭제됨

---

## 사용자 북마크 API 엔드포인트

**모듈**: `api-bookmark`

사용자가 북마크한 항목을 관리하는 API입니다. JWT 토큰에서 userId를 추출하여 해당 사용자의 북마크만 타게팅합니다.

**데이터베이스**: 
- **Command Side (쓰기)**: Aurora MySQL `bookmark` 스키마
  - `bookmarks` 테이블: 북마크 정보 저장
  - `bookmark_history` 테이블: 북마크 변경 이력 저장
- **Query Side (읽기)**: MongoDB Atlas `BookmarkDocument`

**스키마 설정**:
- `api-bookmark-application.yml`에서 `module.aurora.schema=bookmark` 설정
- `datasource/aurora/src/main/resources/application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적으로 `bookmark` 스키마에 연결

**중요**: 모든 쓰기 작업은 Aurora MySQL에서 수행되고, 모든 읽기 작업은 MongoDB Atlas에서 수행됩니다. 단, 삭제된 북마크 조회는 CQRS 패턴 예외로 Aurora MySQL에서 수행됩니다.

### 북마크 추가

**엔드포인트**: `POST /api/v1/bookmark`

**설명**: 새로운 북마크를 추가합니다.

**인증**: 필요 (JWT Access Token)

**요청 Body**:
```json
{
  "itemType": "EMERGING_TECH",
  "itemId": "507f1f77bcf86cd799439012",
  "tag": "ai-model",
  "memo": "관심 기술"
}
```

**주의사항**: 요청 body의 `userId`는 무시하고, JWT 토큰에서 추출한 `userId`를 사용합니다.

**데이터 소스**: Aurora MySQL (`Bookmark` 엔티티)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 데이터 검증 (itemType, itemId)
3. 중복 검증 (Aurora MySQL, userId + itemType + itemId, is_deleted=FALSE)
4. `Bookmark` 엔티티 생성 (Aurora MySQL, userId 자동 설정)
5. `BookmarkHistory` 엔티티 생성 (operation_type: INSERT)
6. **Kafka 이벤트 발행**: `BookmarkCreatedEvent`
   - 이벤트 페이로드: `bookmarkTsid` (Bookmark.id), `userId`, `itemType`, `itemId`, `tag`, `memo` 등

**제약사항**: `userId + itemType + itemId` UNIQUE 제약조건 (중복 방지)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "bookmarkTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "tag": "algorithm",
    "memo": "참가 예정",
    "bookmarkedAt": "2026-01-07T10:00:00Z"
  }
}
```

---

### 북마크 목록 조회

**엔드포인트**: `GET /api/v1/bookmark`

**설명**: 로그인 사용자의 북마크 목록을 조회합니다.

**인증**: 필요 (JWT Access Token)

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `sort` (String, optional): 정렬 기준 (기본값: "createdAt,desc")
  - 가능한 값: `createdAt,asc`, `createdAt,desc`, `bookmarkedAt,asc`, `bookmarkedAt,desc`
- `itemType` (String, optional): 항목 타입 필터
  - 가능한 값: `EMERGING_TECH`

**데이터 소스**: MongoDB Atlas (`BookmarkDocument`)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `BookmarkDocument` 조회 (MongoDB Atlas, userId 필터링)
3. 페이징 및 정렬 적용

**인덱스 활용**: `userId + createdAt` 복합 인덱스 또는 `userId + itemType + createdAt` 복합 인덱스

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "pageSize": 10,
    "pageNumber": 1,
    "totalPageNumber": 5,
    "totalSize": 50,
    "list": [
      {
        "_id": "507f1f77bcf86cd799439015",
        "bookmarkTsid": "1234567890123456789",
        "userId": "9876543210987654321",
        "itemType": "CONTEST",
        "itemId": "507f1f77bcf86cd799439012",
        "itemTitle": "Codeforces Round 900",
        "itemSummary": "Regular Codeforces contest",
        "tag": "algorithm",
        "memo": "참가 예정",
        "bookmarkedAt": "2026-01-07T10:00:00Z"
      }
    ]
  }
}
```

---

### 북마크 상세 조회

**엔드포인트**: `GET /api/v1/bookmark/{id}`

**설명**: 특정 북마크의 상세 정보를 조회합니다.

**인증**: 필요 (JWT Access Token)

**경로 파라미터**:
- `id` (String, required): 북마크 ID (MongoDB ObjectId 또는 bookmarkTsid)

**데이터 소스**: MongoDB Atlas (`BookmarkDocument`)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `BookmarkDocument` 조회 (MongoDB Atlas, id 또는 bookmarkTsid, userId 필터링)
3. 권한 검증 (본인의 북마크만 조회 가능)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "_id": "507f1f77bcf86cd799439015",
    "bookmarkTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "itemTitle": "Codeforces Round 900",
    "itemSummary": "Regular Codeforces contest",
    "tag": "algorithm",
    "memo": "참가 예정",
    "bookmarkedAt": "2026-01-07T10:00:00Z"
  }
}
```

---

### 북마크 검색

**엔드포인트**: `GET /api/v1/bookmark/search`

**설명**: Full-text search를 사용하여 북마크를 검색합니다.

**인증**: 필요 (JWT Access Token)

**쿼리 파라미터**:
- `q` (String, required): 검색어
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `itemType` (String, optional): 항목 타입 필터
  - 가능한 값: `CONTEST`, `NEWS_ARTICLE`

**데이터 소스**: MongoDB Atlas (`BookmarkDocument`, Full-text search)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `BookmarkDocument` 검색 (MongoDB Atlas, userId 필터링, Full-text search)
3. 페이징 및 정렬 적용

**응답 형식**: 북마크 목록 조회와 동일

---

### 북마크 수정

**엔드포인트**: `PUT /api/v1/bookmark/{id}`

**설명**: 북마크 정보를 수정합니다.

**인증**: 필요 (JWT Access Token)

**경로 파라미터**:
- `id` (String, required): 북마크 ID (bookmarkTsid, TSID)

**요청 Body**:
```json
{
  "tag": "updated-algorithm",
  "memo": "수정된 메모"
}
```

**데이터 소스**: Aurora MySQL (`Bookmark` 엔티티)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `Bookmark` 엔티티 조회 (Aurora MySQL, id=bookmarkTsid, userId 검증)
3. 권한 검증 (본인의 북마크만 수정 가능)
4. `Bookmark` 엔티티 업데이트 (Aurora MySQL)
5. `BookmarkHistory` 엔티티 생성 (operation_type: UPDATE)
6. **Kafka 이벤트 발행**: `BookmarkUpdatedEvent`
   - 이벤트 페이로드: `bookmarkTsid`, 변경된 필드 정보 포함

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "bookmarkTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "tag": "updated-algorithm",
    "memo": "수정된 메모",
    "bookmarkedAt": "2026-01-07T10:00:00Z"
  }
}
```

---

### 북마크 삭제 (Soft Delete)

**엔드포인트**: `DELETE /api/v1/bookmark/{id}`

**설명**: 북마크를 삭제합니다 (Soft Delete).

**인증**: 필요 (JWT Access Token)

**경로 파라미터**:
- `id` (String, required): 북마크 ID (bookmarkTsid, TSID)

**데이터 소스**: Aurora MySQL (`Bookmark` 엔티티)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `Bookmark` 엔티티 조회 (Aurora MySQL, id=bookmarkTsid, userId 검증)
3. 권한 검증 (본인의 북마크만 삭제 가능)
4. `Bookmark` 엔티티 Soft Delete (Aurora MySQL, is_deleted=TRUE, deleted_at 설정, deleted_by=userId)
5. `BookmarkHistory` 엔티티 생성 (operation_type: DELETE)
6. **Kafka 이벤트 발행**: `BookmarkDeletedEvent`
   - 이벤트 페이로드: `bookmarkTsid`, `userId`, `deletedAt` 등
   - MongoDB Atlas의 `BookmarkDocument`는 물리적 삭제 (MongoDB는 Soft Delete 미지원)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": null
}
```

---

### 북마크 복원

**엔드포인트**: `POST /api/v1/bookmark/{id}/restore`

**설명**: 삭제된 북마크를 복원합니다.

**인증**: 필요 (JWT Access Token)

**경로 파라미터**:
- `id` (String, required): 북마크 ID (bookmarkTsid, TSID)

**데이터 소스**: Aurora MySQL (`Bookmark` 엔티티)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `Bookmark` 엔티티 조회 (Aurora MySQL, id=bookmarkTsid, userId 검증, is_deleted=TRUE)
3. 권한 검증 (본인의 북마크만 복원 가능)
4. `Bookmark` 엔티티 복원 (Aurora MySQL, is_deleted=FALSE, deleted_at=null, deleted_by=null)
5. `BookmarkHistory` 엔티티 생성 (operation_type: UPDATE)
6. **Kafka 이벤트 발행**: `BookmarkRestoredEvent`
   - 이벤트 페이로드: `bookmarkTsid`, `userId`, `itemType`, `itemId`, `tag`, `memo` 등
   - MongoDB Atlas의 `BookmarkDocument` 새로 생성 (MongoDB는 Soft Delete 미지원이므로 복원 시 재생성 필요)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "bookmarkTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "tag": "algorithm",
    "memo": "참가 예정",
    "bookmarkedAt": "2026-01-07T10:00:00Z"
  }
}
```

---

### 삭제된 북마크 목록 조회

**엔드포인트**: `GET /api/v1/bookmark/deleted`

**설명**: 삭제된 북마크 목록을 조회합니다.

**인증**: 필요 (JWT Access Token)

**주의사항**: MongoDB Atlas는 Soft Delete를 구현하지 않으므로, 삭제된 북마크는 Aurora MySQL에서만 조회 가능합니다 (CQRS 패턴 예외).

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `sort` (String, optional): 정렬 기준 (기본값: "deletedAt,desc")
  - 가능한 값: `deletedAt,asc`, `deletedAt,desc`

**데이터 소스**: Aurora MySQL (`Bookmark` 엔티티, CQRS 패턴 예외)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `Bookmark` 엔티티 조회 (Aurora MySQL, userId + is_deleted=TRUE 필터링)
3. 페이징 및 정렬 적용

**인덱스 활용**: `user_id + is_deleted` 복합 인덱스

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "pageSize": 10,
    "pageNumber": 1,
    "totalPageNumber": 2,
    "totalSize": 15,
    "list": [
      {
        "bookmarkTsid": "1234567890123456789",
        "userId": "9876543210987654321",
        "itemType": "CONTEST",
        "itemId": "507f1f77bcf86cd799439012",
        "tag": "algorithm",
        "memo": "참가 예정",
        "bookmarkedAt": "2026-01-07T10:00:00Z",
        "deletedAt": "2026-01-08T10:00:00Z"
      }
    ]
  }
}
```

---

### 변경 이력 조회

**엔드포인트**: `GET /api/v1/bookmark/history/{entityId}`

**설명**: 특정 북마크 엔티티의 변경 이력을 조회합니다. `api-bookmark` 모듈은 `bookmark` 엔티티 타입의 변경 이력을 조회합니다.

**인증**: 필요 (JWT Access Token, 관리자 또는 본인)

**경로 파라미터**:
- `entityId` (String, required): 북마크 엔티티 ID (TSID)

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `operationType` (String, optional): 작업 타입 필터
  - 가능한 값: `INSERT`, `UPDATE`, `DELETE`
- `startDate` (String, optional): 시작 일시 (ISO 8601)
- `endDate` (String, optional): 종료 일시 (ISO 8601)

**데이터 소스**: Aurora MySQL (`BookmarkHistory` 엔티티, CQRS 패턴 예외)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자 또는 본인)
3. `BookmarkHistory` 테이블에서 히스토리 엔티티 조회 (Aurora MySQL, 필터링 및 페이징)

**인덱스 활용**: `operation_type + changed_at` 복합 인덱스

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "pageSize": 10,
    "pageNumber": 1,
    "totalPageNumber": 3,
    "totalSize": 25,
    "list": [
      {
        "historyId": "1111111111111111111",
        "entityId": "1234567890123456789",
        "operationType": "UPDATE",
        "beforeData": {
          "tag": "algorithm",
          "memo": "참가 예정"
        },
        "afterData": {
          "tag": "updated-algorithm",
          "memo": "수정된 메모"
        },
        "changedBy": "9876543210987654321",
        "changedAt": "2026-01-08T10:00:00Z",
        "changeReason": "사용자 요청"
      }
    ]
  }
}
```

---

### 특정 시점 데이터 조회

**엔드포인트**: `GET /api/v1/bookmark/history/{entityId}/at`

**설명**: 특정 시점의 북마크 엔티티 데이터를 조회합니다. `api-bookmark` 모듈은 `bookmark` 엔티티 타입의 특정 시점 데이터를 조회합니다.

**인증**: 필요 (JWT Access Token, 관리자 또는 본인)

**경로 파라미터**:
- `entityId` (String, required): 북마크 엔티티 ID (TSID)

**쿼리 파라미터**:
- `timestamp` (String, required): 시점 (ISO 8601)

**데이터 소스**: Aurora MySQL (히스토리 테이블의 `before_data`/`after_data` JSON 필드, CQRS 패턴 예외)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자 또는 본인)
3. 히스토리 테이블에서 해당 시점 이전의 가장 최근 이력 조회
4. `after_data` JSON 필드에서 데이터 추출

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "entityId": "1234567890123456789",
    "timestamp": "2026-01-08T10:00:00Z",
    "data": {
      "bookmarkTsid": "1234567890123456789",
      "userId": "9876543210987654321",
      "itemType": "CONTEST",
      "itemId": "507f1f77bcf86cd799439012",
      "tag": "updated-algorithm",
      "memo": "수정된 메모"
    }
  }
}
```

---

### 특정 버전으로 복구

**엔드포인트**: `POST /api/v1/bookmark/history/{entityId}/restore`

**설명**: 특정 히스토리 버전으로 북마크 엔티티를 복구합니다. `api-bookmark` 모듈은 `bookmark` 엔티티 타입의 특정 버전을 복구합니다.

**인증**: 필요 (JWT Access Token, 관리자만)

**경로 파라미터**:
- `entityId` (String, required): 북마크 엔티티 ID (TSID)

**쿼리 파라미터**:
- `historyId` (String, required): 히스토리 ID (TSID)

**데이터 소스**: Aurora MySQL (히스토리 테이블 및 엔티티 테이블)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자만)
3. 히스토리 엔티티 조회 (Aurora MySQL, historyId)
4. `after_data` JSON 필드를 기반으로 엔티티 복구 (Aurora MySQL)
5. 히스토리 엔티티 생성 (operation_type: UPDATE)
6. **Kafka 이벤트 발행**: `BookmarkUpdatedEvent`

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "message": "엔티티가 성공적으로 복구되었습니다.",
    "entityId": "1234567890123456789",
    "restoredHistoryId": "1111111111111111111"
  }
}
```

---

## 인증 API 엔드포인트

**모듈**: `api-auth`

사용자 인증 및 토큰 관리를 위한 API입니다. 모든 쓰기 작업은 Aurora MySQL에서 수행됩니다.

**데이터베이스**: 
- **Command Side (쓰기)**: Aurora MySQL `auth` 스키마
  - `providers`, `users`, `admins`, `refresh_tokens`, `email_verifications`, `user_history`, `admin_history` 테이블 관리

**스키마 설정**:
- `api-auth-application.yml`에서 `module.aurora.schema=auth` 설정
- `datasource/aurora/src/main/resources/application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적으로 `auth` 스키마에 연결

### 회원가입

**엔드포인트**: `POST /api/v1/auth/signup`

**설명**: 새로운 사용자를 등록합니다.

**인증**: 불필요

**요청 Body**:
```json
{
  "email": "user@example.com",
  "username": "john_doe",
  "password": "securePassword123"
}
```

**데이터 소스**: Aurora MySQL (`User` 엔티티, `EmailVerification` 엔티티)

**처리 로직**:
1. 이메일 중복 검증 (Aurora MySQL, `is_deleted=FALSE` 조건 포함)
2. 사용자명 중복 검증 (Aurora MySQL, `is_deleted=FALSE` 조건 포함)
3. 비밀번호 정책 검증 (최소 8자, 대소문자/숫자/특수문자 중 2가지 이상 포함)
4. 비밀번호 해시 생성 (BCrypt 알고리즘, salt rounds: 12)
5. 트랜잭션 시작
6. `User` 엔티티 생성 (Aurora MySQL)
7. `EmailVerification` 엔티티 생성 (Aurora MySQL, `type=EMAIL_VERIFICATION`, `expires_at`: 현재 시간 + 24시간)
8. `UserHistory` 엔티티 생성 (operation_type: INSERT)
9. 트랜잭션 커밋
10. **Kafka 이벤트 발행**: `UserCreatedEvent`
11. 이메일 인증 토큰 발송 (비동기 처리, 실패 시 재시도 로직 실행)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "userId": "1234567890123456789",
    "email": "user@example.com",
    "username": "john_doe",
    "message": "회원가입이 완료되었습니다. 이메일 인증을 완료해주세요."
  }
}
```

---

### 로그인

**엔드포인트**: `POST /api/v1/auth/login`

**설명**: 사용자 로그인을 처리하고 JWT 토큰을 발급합니다.

**인증**: 불필요

**요청 Body**:
```json
{
  "email": "user@example.com",
  "password": "securePassword123"
}
```

**데이터 소스**: Aurora MySQL (`User` 엔티티, `RefreshToken` 엔티티)

**처리 로직**:
1. 이메일로 `User` 엔티티 조회 (Aurora MySQL, `is_deleted=FALSE` 조건 포함)
2. 비밀번호 검증 (BCrypt 알고리즘으로 해시된 비밀번호와 입력 비밀번호 비교)
3. 이메일 인증 여부 확인 (`is_email_verified=TRUE` 확인, `FALSE`인 경우 로그인 차단)
4. JWT Access Token 생성 (만료 시간: 3600초=1시간, 서명 알고리즘: HS256 또는 RS256)
5. JWT Refresh Token 생성 (만료 시간: 7일)
6. 트랜잭션 시작
7. `RefreshToken` 엔티티 생성 (Aurora MySQL, `expires_at`: 현재 시간 + 7일)
8. `User` 엔티티 업데이트 (`last_login_at` 필드 업데이트)
9. `UserHistory` 엔티티 생성 (operation_type: UPDATE)
10. 트랜잭션 커밋

**Rate Limiting**: 5회/분 (무차별 대입 공격 방지)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600,
    "refreshTokenExpiresIn": 604800
  }
}
```

---

### 로그아웃

**엔드포인트**: `POST /api/v1/auth/logout`

**설명**: 사용자 로그아웃을 처리하고 Refresh Token을 무효화합니다.

**인증**: 필요 (JWT Access Token)

**요청 Body**:
```json
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**데이터 소스**: Aurora MySQL (`RefreshToken` 엔티티)

**처리 로직**:
1. JWT 토큰에서 userId 추출
2. 트랜잭션 시작
3. `RefreshToken` 엔티티 조회 (Aurora MySQL, `token=요청의 refreshToken`, `is_deleted=FALSE`, `expires_at` 확인)
4. RefreshToken의 `userId`와 JWT 토큰의 `userId` 일치 여부 검증 (불일치 시 에러 반환)
5. `RefreshToken` 엔티티 Soft Delete (`is_deleted=TRUE`, `deleted_at` 설정, `deleted_by=userId`)
6. `UserHistory` 엔티티 생성 (operation_type: UPDATE)
7. 트랜잭션 커밋

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": null
}
```

---

### 토큰 갱신

**엔드포인트**: `POST /api/v1/auth/refresh`

**설명**: Refresh Token을 사용하여 새로운 Access Token을 발급합니다.

**인증**: 불필요 (Refresh Token 필요)

**요청 Body**:
```json
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**데이터 소스**: Aurora MySQL (`RefreshToken` 엔티티)

**처리 로직**:
1. Refresh Token 검증 (JWT 서명 검증)
2. `RefreshToken` 엔티티 조회 (Aurora MySQL, `token=요청의 refreshToken`, `is_deleted=FALSE`, `expires_at` 확인)
3. 새로운 Access Token 생성 (만료 시간: 3600초=1시간)
4. 트랜잭션 시작
5. 기존 `RefreshToken` 엔티티 Soft Delete (`is_deleted=TRUE`, `deleted_at` 설정)
6. 새로운 `RefreshToken` 엔티티 생성 (Aurora MySQL, `expires_at`: 현재 시간 + 7일)
7. `UserHistory` 엔티티 생성 (operation_type: UPDATE)
8. 트랜잭션 커밋

**참고**: RefreshToken 회전(Rotation) 전략 적용 - 기존 토큰 무효화 후 새 토큰 생성 (RFC 6749 베스트 프랙티스)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600
  }
}
```

---

### 이메일 인증

**엔드포인트**: `GET /api/v1/auth/verify-email`

**설명**: 이메일 인증 토큰을 검증하고 사용자 이메일을 인증합니다.

**인증**: 불필요

**쿼리 파라미터**:
- `token` (String, required): 이메일 인증 토큰

**데이터 소스**: Aurora MySQL (`EmailVerification` 엔티티, `User` 엔티티)

**처리 로직**:
1. `EmailVerification` 엔티티 조회 (Aurora MySQL, `token`, `type=EMAIL_VERIFICATION`, `is_deleted=FALSE`, `expires_at` 확인)
2. 토큰 만료 여부 확인 (`expires_at` 확인)
3. 중복 인증 방지 확인 (`verified_at`이 이미 설정되어 있는 경우 에러 반환)
4. 트랜잭션 시작
5. `EmailVerification` 엔티티 업데이트 (`verified_at` 설정, 중복 설정 방지)
6. `User` 엔티티 업데이트 (`is_email_verified` 필드를 `TRUE`로 설정)
7. `UserHistory` 엔티티 생성 (operation_type: UPDATE)
8. 트랜잭션 커밋
9. **Kafka 이벤트 발행**: `UserUpdatedEvent`

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "message": "이메일 인증이 완료되었습니다."
  }
}
```

---

### 비밀번호 재설정 요청

**엔드포인트**: `POST /api/v1/auth/reset-password`

**설명**: 비밀번호 재설정 토큰을 발급합니다.

**인증**: 불필요

**요청 Body**:
```json
{
  "email": "user@example.com"
}
```

**데이터 소스**: Aurora MySQL (`EmailVerification` 엔티티)

**처리 로직**:
1. 이메일로 `User` 엔티티 조회 (Aurora MySQL, `is_deleted=FALSE` 조건 포함)
2. 비밀번호 재설정 토큰 생성 (암호학적으로 안전한 랜덤 토큰)
3. 트랜잭션 시작
4. 동일 이메일의 기존 `PASSWORD_RESET` 타입 토큰 무효화 (Soft Delete 처리, `email + type` 복합 인덱스 활용)
5. `EmailVerification` 엔티티 생성 (Aurora MySQL, `type=PASSWORD_RESET`, `expires_at`: 현재 시간 + 24시간)
6. 트랜잭션 커밋
7. 이메일 발송 (비동기 처리, 존재하지 않는 이메일인 경우에도 성공 응답 반환 - 보안상 일반적, 실패 시 재시도 로직 실행)

**Rate Limiting**: 3회/시간 (무차별 대입 공격 방지)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "message": "비밀번호 재설정 이메일이 발송되었습니다."
  }
}
```

---

### 비밀번호 재설정 확인

**엔드포인트**: `POST /api/v1/auth/reset-password/confirm`

**설명**: 비밀번호 재설정 토큰을 검증하고 새로운 비밀번호를 설정합니다.

**인증**: 불필요

**요청 Body**:
```json
{
  "token": "reset-token-123",
  "newPassword": "newSecurePassword123"
}
```

**데이터 소스**: Aurora MySQL (`EmailVerification` 엔티티, `User` 엔티티)

**처리 로직**:
1. `EmailVerification` 엔티티 조회 (Aurora MySQL, `token`, `type=PASSWORD_RESET`, `is_deleted=FALSE`, `expires_at` 확인)
2. 토큰 만료 여부 확인 (`expires_at` 확인)
3. 토큰 재사용 방지 확인 (`verified_at`이 이미 설정되어 있는 경우 에러 반환)
4. 비밀번호 정책 검증 (최소 8자, 대소문자/숫자/특수문자 중 2가지 이상 포함)
5. 비밀번호 재사용 방지 확인 (이전 비밀번호와 동일한지 검증, BCrypt로 해시된 비밀번호 비교)
6. 새로운 비밀번호 해시 생성 (BCrypt 알고리즘, salt rounds: 12)
7. 트랜잭션 시작
8. `User` 엔티티 업데이트 (`password` 필드 업데이트)
9. `EmailVerification` 엔티티 업데이트 (`verified_at` 설정, 중복 설정 방지)
10. `UserHistory` 엔티티 생성 (operation_type: UPDATE)
11. 트랜잭션 커밋
12. **Kafka 이벤트 발행**: `UserUpdatedEvent`

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "message": "비밀번호가 성공적으로 변경되었습니다."
  }
}
```

---

### OAuth 2.0 SNS 로그인

#### 1. OAuth 로그인 시작

**엔드포인트**: `GET /api/v1/auth/oauth2/{provider}`

**설명**: OAuth 2.0 로그인을 시작합니다.

**인증**: 불필요

**경로 파라미터**:
- `provider` (String, required): OAuth 제공자 (예: `google`, `github`)

**데이터 소스**: Aurora MySQL (`Provider` 엔티티)

**처리 로직**:
1. `Provider` 엔티티 조회 (Aurora MySQL, `name=provider`, `is_enabled=TRUE`, `is_deleted=FALSE`)
2. CSRF 방지를 위한 `state` 파라미터 생성 (암호학적으로 안전한 랜덤 토큰, 최소 32바이트 권장)
3. `state` 파라미터를 **Redis에 저장** (Provider 정보와 함께 저장, 만료 시간: 10분)
   - Key 형식: `oauth:state:{state_value}`
   - Value: Provider 이름 (예: "GOOGLE", "NAVER", "KAKAO")
   - TTL: 10분 (600초) - 자동 만료
   - 구현: `OAuthStateService.saveState(state, providerName)`
4. OAuth 인증 URL 생성 (`state` 파라미터 포함)
5. 리다이렉트

**State 파라미터 저장 방식:**
- **권장 방법: Redis 저장**
  - Stateless 아키텍처와 완벽 호환
  - 분산 환경 지원 (여러 서버 인스턴스 간 state 공유)
  - TTL 자동 만료로 관리 단순화
  - 빠른 읽기/쓰기 성능
- **구현 클래스**: 
  - `OAuthStateService` (`api/auth/src/main/java/com/tech/n/ai/api/auth/oauth/OAuthStateService.java`)
  - `OAuthProvider` (`api/auth/src/main/java/com/tech/n/ai/api/auth/oauth/OAuthProvider.java`)
  - `OAuthProviderContract` (`client/feign/src/main/java/.../domain/oauth/contract/OAuthProviderContract.java`)
- **상세 설계**: 
  - `docs/oauth-provider-implementation-guide.md` Section 5.3, 6.2 참조
  - `docs/oauth-feign-client-migration-analysis.md`: OpenFeign 클라이언트 구현 가이드

**참고**: `state` 파라미터는 OAuth 2.0 표준(RFC 6749 Section 10.12)에 따라 CSRF 공격 방지를 위한 필수 보안 메커니즘입니다. 콜백 시 검증하여 요청의 유효성을 확인하고, 검증 완료 후 즉시 삭제합니다.

**Rate Limiting**: 10회/분 (무차별 대입 공격 방지)

**응답**: OAuth 제공자 인증 페이지로 리다이렉트

---

#### 2. OAuth 로그인 콜백

**엔드포인트**: `GET /api/v1/auth/oauth2/{provider}/callback`

**설명**: OAuth 2.0 로그인 콜백을 처리합니다.

**인증**: 불필요

**경로 파라미터**:
- `provider` (String, required): OAuth 제공자 (예: `google`, `github`)

**쿼리 파라미터**:
- `code` (String, required): OAuth 인증 코드
- `state` (String, optional): CSRF 방지 상태 토큰 (OAuth 로그인 시작 시 생성된 값)

**데이터 소스**: 
- Redis (`oauth:state:{state_value}` - State 파라미터 저장)
- Aurora MySQL (`Provider` 엔티티, `User` 엔티티, `RefreshToken` 엔티티)

**처리 로직**:
1. `state` 파라미터 검증 (Redis에서 조회, 저장된 값과 일치 여부 확인, Provider 정보도 함께 검증, CSRF 방지)
   - Redis Key: `oauth:state:{state_value}`
   - 구현: `OAuthStateService.validateAndDeleteState(state, providerName)`
   - 검증 실패 시: `UnauthorizedException` 발생
2. 검증 완료 후 `state` 값 즉시 삭제 (일회성 사용, Replay Attack 방지)
3. `Provider` 엔티티 조회 (Aurora MySQL, `is_enabled=TRUE`, `is_deleted=FALSE`)
3. OAuth 인증 코드로 Access Token 교환 (실패 시 에러 반환)
   - 구현: `OAuthProvider.exchangeAccessToken()` → `OAuthProviderContract.exchangeAccessToken()` → OpenFeign 클라이언트
   - 상세 설계: `docs/oauth-provider-implementation-guide.md` Section 5.3 참조
4. OAuth 제공자 API로 사용자 정보 조회 (실패 시 에러 반환)
   - 구현: `OAuthProvider.getUserInfo()` → `OAuthProviderContract.getUserInfo()` → OpenFeign 클라이언트
   - 상세 설계: `docs/oauth-provider-implementation-guide.md` Section 5.3 참조
5. 트랜잭션 시작
6. `User` 엔티티 조회/생성 (Aurora MySQL, `provider_id + provider_user_id` 복합 인덱스 활용, `is_deleted=FALSE` 조건 포함)
   - 존재하지 않으면 `User` 엔티티 생성 (`password=NULL`, OAuth 사용자는 비밀번호 없음)
   - 존재하면 `User` 엔티티 업데이트
   - `UserHistory` 엔티티 생성 (operation_type: INSERT 또는 UPDATE)
7. JWT Access Token 생성 (만료 시간: 3600초=1시간)
8. JWT Refresh Token 생성 (만료 시간: 7일)
9. `RefreshToken` 엔티티 생성 (Aurora MySQL, `expires_at`: 현재 시간 + 7일)
10. 트랜잭션 커밋
11. **Kafka 이벤트 발행**: `UserCreatedEvent` 또는 `UserUpdatedEvent`

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600,
    "refreshTokenExpiresIn": 604800
  }
}
```

---

### 변경 이력 조회

**상태**: ⚠️ **미구현** - 현재 구현되지 않았습니다. `UserHistory`, `AdminHistory` 엔티티는 Aurora MySQL에 정의되어 있으나, API 엔드포인트는 아직 구현되지 않았습니다.

**엔드포인트**: `GET /api/v1/auth/history/{entityType}/{entityId}`

**설명**: 특정 엔티티의 변경 이력을 조회합니다. `api-auth` 모듈은 `user`, `admin` 엔티티 타입의 변경 이력을 조회합니다.

**인증**: 필요 (JWT Access Token, 관리자 또는 본인)

**경로 파라미터**:
- `entityType` (String, required): 엔티티 타입
  - 가능한 값: `user`, `admin`
- `entityId` (String, required): 엔티티 ID (TSID)

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `operationType` (String, optional): 작업 타입 필터
  - 가능한 값: `INSERT`, `UPDATE`, `DELETE`
- `startDate` (String, optional): 시작 일시 (ISO 8601)
- `endDate` (String, optional): 종료 일시 (ISO 8601)

**데이터 소스**: Aurora MySQL (`UserHistory`, `AdminHistory` 엔티티, CQRS 패턴 예외)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자 또는 본인)
3. 엔티티 타입에 따라 히스토리 테이블 선택:
   - `user`: `UserHistory` 테이블
   - `admin`: `AdminHistory` 테이블
4. 히스토리 엔티티 조회 (Aurora MySQL, 필터링 및 페이징)

**인덱스 활용**: `operation_type + changed_at` 복합 인덱스

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "pageSize": 10,
    "pageNumber": 1,
    "totalPageNumber": 3,
    "totalSize": 25,
    "list": [
      {
        "historyId": "1111111111111111111",
        "entityId": "1234567890123456789",
        "operationType": "UPDATE",
        "beforeData": {
          "username": "john_doe",
          "email": "user@example.com"
        },
        "afterData": {
          "username": "john_doe_updated",
          "email": "user@example.com"
        },
        "changedBy": "9876543210987654321",
        "changedAt": "2026-01-08T10:00:00Z",
        "changeReason": "사용자 요청"
      }
    ]
  }
}
```

---

### 특정 시점 데이터 조회

**상태**: ⚠️ **미구현** - 현재 구현되지 않았습니다.

**엔드포인트**: `GET /api/v1/auth/history/{entityType}/{entityId}/at`

**설명**: 특정 시점의 엔티티 데이터를 조회합니다. `api-auth` 모듈은 `user`, `admin` 엔티티 타입의 특정 시점 데이터를 조회합니다.

**인증**: 필요 (JWT Access Token, 관리자 또는 본인)

**경로 파라미터**:
- `entityType` (String, required): 엔티티 타입
  - 가능한 값: `user`, `admin`
- `entityId` (String, required): 엔티티 ID (TSID)

**쿼리 파라미터**:
- `timestamp` (String, required): 시점 (ISO 8601)

**데이터 소스**: Aurora MySQL (히스토리 테이블의 `before_data`/`after_data` JSON 필드, CQRS 패턴 예외)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자 또는 본인)
3. 히스토리 테이블에서 해당 시점 이전의 가장 최근 이력 조회
4. `after_data` JSON 필드에서 데이터 추출

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "entityId": "1234567890123456789",
    "timestamp": "2026-01-08T10:00:00Z",
    "data": {
      "userTsid": "1234567890123456789",
      "userId": "9876543210987654321",
      "username": "john_doe",
      "email": "user@example.com"
    }
  }
}
```

---

### 특정 버전으로 복구

**상태**: ⚠️ **미구현** - 현재 구현되지 않았습니다.

**엔드포인트**: `POST /api/v1/auth/history/{entityType}/{entityId}/restore`

**설명**: 특정 히스토리 버전으로 엔티티를 복구합니다. `api-auth` 모듈은 `user`, `admin` 엔티티 타입의 특정 버전을 복구합니다.

**인증**: 필요 (JWT Access Token, 관리자만)

**경로 파라미터**:
- `entityType` (String, required): 엔티티 타입
  - 가능한 값: `user`, `admin`
- `entityId` (String, required): 엔티티 ID (TSID)

**쿼리 파라미터**:
- `historyId` (String, required): 히스토리 ID (TSID)

**데이터 소스**: Aurora MySQL (히스토리 테이블 및 엔티티 테이블)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자만)
3. 히스토리 엔티티 조회 (Aurora MySQL, historyId)
4. `after_data` JSON 필드를 기반으로 엔티티 복구 (Aurora MySQL)
5. 히스토리 엔티티 생성 (operation_type: UPDATE)
6. **Kafka 이벤트 발행**: 엔티티 타입에 따라 해당 이벤트 발행
   - `user`: `UserUpdatedEvent`
   - `admin`: `AdminUpdatedEvent`

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "message": "엔티티가 성공적으로 복구되었습니다.",
    "entityId": "1234567890123456789",
    "restoredHistoryId": "1111111111111111111"
  }
}
```

---

## 챗봇 API 엔드포인트

**모듈**: `api-chatbot`

사용자와 RAG 기반 챗봇이 대화할 수 있는 API입니다. JWT 토큰에서 userId를 추출하여 해당 사용자의 세션만 타게팅합니다.

**데이터베이스**: 
- **Command Side (쓰기)**: Aurora MySQL (세션 및 메시지 저장)
- **Query Side (읽기)**: MongoDB Atlas (RAG 검색용 Document 조회)

**상세 설계**: 챗봇 구현 상세는 `docs/step12/rag-chatbot-design.md` 문서를 참고하세요.

### 챗봇 대화

**엔드포인트**: `POST /api/v1/chatbot`

**설명**: 챗봇과 대화를 시작하거나 기존 세션에 메시지를 추가합니다.

**인증**: 필요 (JWT Access Token)

**요청 Body**:
```json
{
  "message": "다음 주에 열리는 알고리즘 대회가 있나요?",
  "conversationId": "optional-session-id",
  "options": {
    "includeContests": true,
    "includeNews": true,
    "includeBookmarks": false,
    "maxResults": 5,
    "minSimilarityScore": 0.7
  }
}
```

**데이터 소스**: 
- MongoDB Atlas (RAG 검색: EmergingTechDocument)
- Aurora MySQL (세션 및 메시지 저장)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 세션 관리 (conversationId가 없으면 새 세션 생성)
3. RAG 검색 수행 (MongoDB Atlas Vector Search)
4. LLM 호출 (OpenAI GPT-4o-mini)
5. 응답 생성 및 메시지 저장 (Aurora MySQL)
6. 응답 반환

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "response": "다음 주에 열리는 알고리즘 대회로는 Codeforces Round 900이 있습니다...",
    "sources": [
      {
        "documentId": "507f1f77bcf86cd799439012",
        "title": "Codeforces Round 900",
        "snippet": "Regular Codeforces contest",
        "url": "https://codeforces.com/contests/1900",
        "collection": "contests",
        "score": 0.95
      }
    ],
    "conversationId": "session-id-123",
    "sessionInfo": {
      "title": "알고리즘 대회 문의",
      "createdAt": "2026-01-07T10:00:00Z",
      "messageCount": 2
    },
    "tokenUsage": {
      "inputTokens": 150,
      "outputTokens": 200,
      "totalTokens": 350,
      "estimatedCost": 0.0001
    }
  }
}
```

---

### 세션 목록 조회

**엔드포인트**: `GET /api/v1/chatbot/sessions`

**설명**: 로그인 사용자의 대화 세션 목록을 조회합니다.

**인증**: 필요 (JWT Access Token)

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 20)

**데이터 소스**: Aurora MySQL (세션 테이블)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 세션 목록 조회 (Aurora MySQL, userId 필터링, lastMessageAt 기준 내림차순 정렬)
3. 페이징 적용

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "content": [
      {
        "sessionId": "session-id-123",
        "title": "알고리즘 대회 문의",
        "lastMessageAt": "2026-01-07T10:05:00Z",
        "messageCount": 5
      }
    ],
    "totalElements": 10,
    "totalPages": 1,
    "number": 0,
    "size": 20
  }
}
```

---

### 세션 상세 조회

**엔드포인트**: `GET /api/v1/chatbot/sessions/{sessionId}`

**설명**: 특정 세션의 상세 정보를 조회합니다.

**인증**: 필요 (JWT Access Token)

**경로 파라미터**:
- `sessionId` (String, required): 세션 ID

**데이터 소스**: Aurora MySQL (세션 테이블)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 세션 조회 (Aurora MySQL, sessionId, userId 검증)
3. 권한 검증 (본인의 세션만 조회 가능)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "sessionId": "session-id-123",
    "title": "알고리즘 대회 문의",
    "createdAt": "2026-01-07T10:00:00Z",
    "lastMessageAt": "2026-01-07T10:05:00Z",
    "messageCount": 5
  }
}
```

---

### 메시지 히스토리 조회

**엔드포인트**: `GET /api/v1/chatbot/sessions/{sessionId}/messages`

**설명**: 특정 세션의 메시지 히스토리를 조회합니다.

**인증**: 필요 (JWT Access Token)

**경로 파라미터**:
- `sessionId` (String, required): 세션 ID

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 50)

**데이터 소스**: Aurora MySQL (메시지 테이블)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 세션 소유권 검증 (Aurora MySQL, sessionId, userId)
3. 메시지 목록 조회 (Aurora MySQL, sessionId 필터링, sequenceNumber 기준 오름차순 정렬)
4. 페이징 적용

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "content": [
      {
        "messageId": "msg-id-1",
        "role": "USER",
        "content": "다음 주에 열리는 알고리즘 대회가 있나요?",
        "sequenceNumber": 1,
        "createdAt": "2026-01-07T10:00:00Z"
      },
      {
        "messageId": "msg-id-2",
        "role": "ASSISTANT",
        "content": "다음 주에 열리는 알고리즘 대회로는 Codeforces Round 900이 있습니다...",
        "sequenceNumber": 2,
        "createdAt": "2026-01-07T10:00:05Z"
      }
    ],
    "totalElements": 10,
    "totalPages": 1,
    "number": 0,
    "size": 50
  }
}
```

---

### 세션 삭제

**엔드포인트**: `DELETE /api/v1/chatbot/sessions/{sessionId}`

**설명**: 특정 세션을 삭제합니다.

**인증**: 필요 (JWT Access Token)

**경로 파라미터**:
- `sessionId` (String, required): 세션 ID

**데이터 소스**: Aurora MySQL (세션 테이블)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 세션 소유권 검증 (Aurora MySQL, sessionId, userId)
3. 세션 삭제 (Aurora MySQL, Soft Delete 또는 물리적 삭제)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": null
}
```

---

## CQRS 패턴 적용

### 읽기/쓰기 분리 원칙

| 작업 유형 | 데이터 소스 | 예외 사항 |
|-----------|------------|----------|
| 읽기 작업 | MongoDB Atlas (Query Side) | 변경 이력 조회, 삭제된 북마크 조회는 Aurora MySQL |
| 쓰기 작업 | Aurora MySQL (Command Side) | 없음 |

### 읽기 작업 (MongoDB Atlas)

- 신기술 동향(Emerging Tech) 목록/상세/검색
- 북마크 목록/상세/검색 조회 (활성 북마크만)
- 챗봇 RAG 검색 (EmergingTechDocument)

### 쓰기 작업 (Aurora MySQL)

- 회원가입, 로그인, 로그아웃, 토큰 갱신
- 이메일 인증, 비밀번호 재설정
- OAuth 2.0 로그인
- 북마크 생성, 수정, 삭제, 복원
- 챗봇 세션 및 메시지 저장

### 내부 API (MongoDB Atlas 쓰기)

- 신기술 동향(Emerging Tech) 수집/저장 (Batch 모듈 전용)

### 예외 사항 (Aurora MySQL 조회)

- 변경 이력 조회: 
  - `GET /api/v1/auth/history/{entityType}/{entityId}` (user, admin) - ⚠️ 미구현
  - `GET /api/v1/bookmark/history/{entityId}` (bookmark)
- 특정 시점 데이터 조회: 
  - `GET /api/v1/auth/history/{entityType}/{entityId}/at` (user, admin) - ⚠️ 미구현
  - `GET /api/v1/bookmark/history/{entityId}/at` (bookmark)
- 특정 버전으로 복구:
  - `POST /api/v1/auth/history/{entityType}/{entityId}/restore` (user, admin) - ⚠️ 미구현
  - `POST /api/v1/bookmark/history/{entityId}/restore` (bookmark)
- 삭제된 북마크 목록 조회: `GET /api/v1/bookmark/deleted`
- 챗봇 세션 목록/상세/메시지 히스토리 조회: `GET /api/v1/chatbot/sessions`, `GET /api/v1/chatbot/sessions/{sessionId}`, `GET /api/v1/chatbot/sessions/{sessionId}/messages`

---

## Kafka 이벤트 발행 전략

### 이벤트 발행 규칙

모든 쓰기 작업 후 반드시 Kafka 이벤트를 발행하여 Command Side와 Query Side 간의 데이터 일관성을 보장합니다.

### 이벤트 목록

#### User 관련 이벤트

1. **UserCreatedEvent**
   - 발행 시점: `User` 엔티티 생성 시
   - 페이로드: `userTsid` (User.id), `userId`, `username`, `email`, `profileImageUrl` 등
   - 동기화 대상: MongoDB Atlas `UserProfileDocument` 생성

2. **UserUpdatedEvent**
   - 발행 시점: `User` 엔티티 수정 시
   - 페이로드: `userTsid`, 변경된 필드 정보 포함
   - 동기화 대상: MongoDB Atlas `UserProfileDocument` 업데이트

3. **UserDeletedEvent**
   - 발행 시점: `User` 엔티티 Soft Delete 시
   - 페이로드: `userTsid`, `userId`, `deletedAt` 등
   - 동기화 대상: MongoDB Atlas `UserProfileDocument` 물리적 삭제

4. **UserRestoredEvent**
   - 발행 시점: `User` 엔티티 복원 시
   - 페이로드: `userTsid`, `userId`, `username`, `email`, `profileImageUrl` 등
   - 동기화 대상: MongoDB Atlas `UserProfileDocument` 새로 생성

#### Bookmark 관련 이벤트

1. **BookmarkCreatedEvent**
   - 발행 시점: `Bookmark` 엔티티 생성 시
   - 페이로드: `bookmarkTsid` (Bookmark.id), `userId`, `itemType`, `itemId`, `tag`, `memo` 등
   - 동기화 대상: MongoDB Atlas `BookmarkDocument` 생성

2. **BookmarkUpdatedEvent**
   - 발행 시점: `Bookmark` 엔티티 수정 시
   - 페이로드: `bookmarkTsid`, 변경된 필드 정보 포함
   - 동기화 대상: MongoDB Atlas `BookmarkDocument` 업데이트

3. **BookmarkDeletedEvent**
   - 발행 시점: `Bookmark` 엔티티 Soft Delete 시
   - 페이로드: `bookmarkTsid`, `userId`, `deletedAt` 등
   - 동기화 대상: MongoDB Atlas `BookmarkDocument` 물리적 삭제

4. **BookmarkRestoredEvent**
   - 발행 시점: `Bookmark` 엔티티 복원 시
   - 페이로드: `bookmarkTsid`, `userId`, `itemType`, `itemId`, `tag`, `memo` 등
   - 동기화 대상: MongoDB Atlas `BookmarkDocument` 새로 생성

### 이벤트 발행 순서

1. Aurora MySQL 트랜잭션 커밋
2. Kafka 이벤트 발행 (트랜잭션 아웃박스 패턴 고려)
3. MongoDB Atlas 동기화 (이벤트 수신 후)

### 동기화 지연 시간

- 목표: 1초 이내
- TSID 필드 기반 1:1 매핑으로 동기화 정확성 보장
  - `User.id(TSID)` → `UserProfileDocument.userTsid`
  - `Bookmark.id(TSID)` → `BookmarkDocument.bookmarkTsid`

---

## 결론

이 설계서는 CQRS 패턴을 기반으로 한 RESTful API 엔드포인트 설계를 제공합니다. 모든 읽기 작업은 MongoDB Atlas에서, 모든 쓰기 작업은 Aurora MySQL에서 수행되며, Kafka 이벤트를 통한 실시간 동기화가 보장됩니다.

### 주요 특징

1. ✅ **RESTful 원칙 준수**: HTTP 메서드와 상태 코드 적절히 사용
2. ✅ **CQRS 패턴 적용**: 읽기/쓰기 엔드포인트 명확히 분리
3. ✅ **JWT 기반 인증**: 사용자별 데이터 타게팅
4. ✅ **이벤트 기반 동기화**: 모든 쓰기 작업 후 Kafka 이벤트 발행
5. ✅ **Soft Delete 지원**: Aurora MySQL에서 Soft Delete 구현

### 다음 단계

1. API 컨트롤러 구현
2. 서비스 레이어 구현
3. Kafka 이벤트 발행 로직 구현
4. MongoDB Atlas 동기화 컨슈머 구현
5. JWT 토큰 인증/인가 로직 구현

---

**문서 버전**: 1.0  
**최종 업데이트**: 2026-01-07  
**작성자**: API Architect

