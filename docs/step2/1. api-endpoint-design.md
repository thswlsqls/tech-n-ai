# RESTful API 엔드포인트 설계서

**작성 일시**: 2026-01-07  
**대상**: API Server 엔드포인트 설계  
**아키텍처**: CQRS 패턴 기반 (Command Side: Aurora MySQL, Query Side: MongoDB Atlas)

## 목차

1. [개요](#개요)
2. [공개 API 엔드포인트](#공개-api-엔드포인트)
3. [사용자 아카이브 API 엔드포인트](#사용자-아카이브-api-엔드포인트)
4. [인증 API 엔드포인트](#인증-api-엔드포인트)
5. [CQRS 패턴 적용](#cqrs-패턴-적용)
6. [Kafka 이벤트 발행 전략](#kafka-이벤트-발행-전략)

---

## 개요

이 설계서는 CQRS 패턴을 기반으로 한 RESTful API 엔드포인트 설계를 다룹니다. 모든 읽기 작업은 MongoDB Atlas(Query Side)에서, 모든 쓰기 작업은 Aurora MySQL(Command Side)에서 수행됩니다.

### API 모듈 구성

이 설계서는 다음 API 모듈들의 엔드포인트를 다룹니다:

- **api-archive**: 사용자 아카이브 관리 API (Aurora MySQL 사용, `archive` 스키마)
  - `api-archive-application.yml`에서 `module.aurora.schema=archive` 설정
  - `application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적 연결
- **api-auth**: 인증 및 사용자 관리 API (Aurora MySQL 사용, `auth` 스키마)
  - `api-auth-application.yml`에서 `module.aurora.schema=auth` 설정
  - `application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적 연결
- **api-contest**: 대회 정보 조회 API (MongoDB Atlas 사용)
  - Contest 데이터의 특성과 읽기 위주 요청이 필요한 비즈니스 요구사항에 따라 MongoDB Atlas 사용
- **api-news**: 뉴스 정보 조회 API (MongoDB Atlas 사용)
  - News 데이터의 특성과 읽기 위주 요청이 필요한 비즈니스 요구사항에 따라 MongoDB Atlas 사용

### 설계 원칙

1. **RESTful 원칙 준수**: HTTP 메서드와 상태 코드를 적절히 사용
2. **CQRS 패턴 적용**: 읽기/쓰기 엔드포인트 명확히 분리
3. **인증 및 권한**: JWT 토큰 기반 인증, 사용자별 데이터 타게팅
4. **이벤트 기반 동기화**: 모든 쓰기 작업 후 Kafka 이벤트 발행
5. **Soft Delete 지원**: 삭제 작업은 Soft Delete로 처리 (Aurora MySQL만)

### API 버전 관리

- **Base URL**: `/api/v1`
- **버전 관리**: URL 경로에 버전 포함 (`/api/v1/...`)

---

## 공개 API 엔드포인트

인증 없이 접근 가능한 공개 API입니다. 모든 읽기 작업은 MongoDB Atlas에서 수행됩니다.

### 출처 API

#### 1. 출처 목록 조회

**엔드포인트**: `GET /api/v1/sources`

**설명**: 정보 출처 목록을 조회합니다.

**인증**: 불필요

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `type` (String, optional): 출처 타입 필터
  - 가능한 값: `API`, `RSS`, `Web Scraping`
- `is_enabled` (Boolean, optional): 활성화 여부 필터

**데이터 소스**: MongoDB Atlas (`SourcesDocument`)

**인덱스 활용**: `type + is_enabled` 복합 인덱스

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "pageSize": 10,
    "pageNumber": 1,
    "totalPageNumber": 1,
    "totalSize": 5,
    "list": [
      {
        "_id": "507f1f77bcf86cd799439011",
        "name": "Codeforces API",
        "type": "API",
        "category": "개발자 대회 정보",
        "url": "https://codeforces.com",
        "apiEndpoint": "https://codeforces.com/api",
        "is_enabled": true
      }
    ]
  }
}
```

---

### 대회 API

**모듈**: `api-contest` 

**데이터 저장소**: MongoDB Atlas Cluster 

**설명**: Contest 관련 데이터는 MongoDB Atlas의 Document로 저장되며, Aurora DB를 사용하지 않습니다. 이는 Contest 데이터의 특성과 읽기 위주 요청이 필요한 비즈니스 요구사항에 따라서 비정형 데이터 구조와 높은 읽기 성능이 필요하기 때문입니다.

**데이터 수집**: `ContestDocument`의 데이터는 `client-scraper` 모듈에서 웹 스크래핑을 통해 수집됩니다. 수집된 대회 정보는 `ContestDocument` 형식으로 MongoDB Atlas에 저장되며, `api-contest` 모듈을 통해 조회됩니다.

**상세 설계**: 웹 스크래핑 모듈의 구현 상세는 `docs/step8/rss-scraper-modules-analysis.md` 문서를 참고하세요. 

#### 1. 대회 목록 조회 

**엔드포인트**: `GET /api/v1/contest` 

**설명**: 개발자 대회 목록을 조회합니다.

**인증**: 불필요

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `sort` (String, optional): 정렬 기준 (기본값: "startDate,desc")
  - 가능한 값: `startDate,asc`, `startDate,desc`, `endDate,asc`, `endDate,desc`
- `sourceId` (String, optional): 출처 ID (ObjectId)
- `status` (String, optional): 대회 상태 필터
  - 가능한 값: `UPCOMING`, `ONGOING`, `ENDED`

**데이터 소스**: MongoDB Atlas (`ContestDocument`)

**인덱스 활용**: `sourceId + startDate` 복합 인덱스

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "pageSize": 10,
    "pageNumber": 1,
    "totalPageNumber": 5,
    "totalSize": 50,
    "list": [
      {
        "_id": "507f1f77bcf86cd799439012",
        "sourceId": "507f1f77bcf86cd799439011",
        "title": "Codeforces Round 900",
        "startDate": "2026-01-15T10:00:00Z",
        "endDate": "2026-01-15T12:30:00Z",
        "status": "UPCOMING",
        "description": "Regular Codeforces contest",
        "url": "https://codeforces.com/contests/1900",
        "metadata": {
          "sourceName": "Codeforces API",
          "prize": null,
          "participants": null,
          "tags": ["algorithm", "competitive-programming"]
        }
      }
    ]
  }
}
```

#### 2. 대회 상세 조회

**엔드포인트**: `GET /api/v1/contest/{id}`

**설명**: 특정 대회의 상세 정보를 조회합니다.

**인증**: 불필요

**경로 파라미터**:
- `id` (String, required): 대회 ID (ObjectId)

**데이터 소스**: MongoDB Atlas (`ContestDocument`)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "_id": "507f1f77bcf86cd799439012",
    "sourceId": "507f1f77bcf86cd799439011",
    "title": "Codeforces Round 900",
    "startDate": "2026-01-15T10:00:00Z",
    "endDate": "2026-01-15T12:30:00Z",
    "status": "UPCOMING",
    "description": "Regular Codeforces contest",
    "url": "https://codeforces.com/contests/1900",
    "metadata": {
      "sourceName": "Codeforces API",
      "prize": null,
      "participants": null,
      "tags": ["algorithm", "competitive-programming"]
    }
  }
}
```

#### 3. 대회 검색

**엔드포인트**: `GET /api/v1/contest/search`

**설명**: Full-text search를 사용하여 대회를 검색합니다.

**인증**: 불필요

**쿼리 파라미터**:
- `q` (String, required): 검색어
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)

**데이터 소스**: MongoDB Atlas (`ContestDocument`, Full-text search)

**응답 형식**: 대회 목록 조회와 동일

---

### 뉴스 API

**모듈**: `api-news`

**데이터 저장소**: MongoDB Atlas Cluster

**설명**: News 관련 데이터는 MongoDB Atlas의 Document로 저장되며, Aurora DB를 사용하지 않습니다. 이는 News 데이터의 특성과 읽기 위주 요청이 필요한 비즈니스 요구사항에 따라서 비정형 데이터 구조와 높은 읽기 성능이 필요하기 때문입니다.

**데이터 수집**: `NewsArticleDocument`의 데이터는 `client-rss` 모듈에서 RSS 피드 파싱을 통해 수집됩니다. 수집된 뉴스 기사는 `NewsArticleDocument` 형식으로 MongoDB Atlas에 저장되며, `api-news` 모듈을 통해 조회됩니다.

**상세 설계**: RSS 피드 파싱 모듈의 구현 상세는 `docs/step8/rss-scraper-modules-analysis.md` 문서를 참고하세요.

#### 1. 뉴스 목록 조회

**엔드포인트**: `GET /api/v1/news`

**설명**: IT 테크 뉴스 목록을 조회합니다.

**인증**: 불필요

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `sort` (String, optional): 정렬 기준 (기본값: "publishedAt,desc")
  - 가능한 값: `publishedAt,asc`, `publishedAt,desc`
- `sourceId` (String, optional): 출처 ID (ObjectId)

**데이터 소스**: MongoDB Atlas (`NewsArticleDocument`)

**인덱스 활용**: `sourceId + publishedAt` 복합 인덱스

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "pageSize": 10,
    "pageNumber": 1,
    "totalPageNumber": 10,
    "totalSize": 100,
    "list": [
      {
        "_id": "507f1f77bcf86cd799439013",
        "sourceId": "507f1f77bcf86cd799439014",
        "title": "Spring Boot 4.0 Released",
        "summary": "Spring Boot 4.0 brings significant improvements...",
        "publishedAt": "2026-01-05T08:00:00Z",
        "url": "https://example.com/news/spring-boot-4",
        "author": "John Doe",
        "metadata": {
          "sourceName": "Hacker News API",
          "tags": ["spring", "java", "framework"],
          "viewCount": 1500,
          "likeCount": 120
        }
      }
    ]
  }
}
```

#### 2. 뉴스 상세 조회

**엔드포인트**: `GET /api/v1/news/{id}`

**설명**: 특정 뉴스 기사의 상세 정보를 조회합니다.

**인증**: 불필요

**경로 파라미터**:
- `id` (String, required): 뉴스 ID (ObjectId)

**데이터 소스**: MongoDB Atlas (`NewsArticleDocument`)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "_id": "507f1f77bcf86cd799439013",
    "sourceId": "507f1f77bcf86cd799439014",
    "title": "Spring Boot 4.0 Released",
    "content": "Spring Boot 4.0 has been released with new features...",
    "summary": "Spring Boot 4.0 brings significant improvements...",
    "publishedAt": "2026-01-05T08:00:00Z",
    "url": "https://example.com/news/spring-boot-4",
    "author": "John Doe",
    "metadata": {
      "sourceName": "Hacker News API",
      "tags": ["spring", "java", "framework"],
      "viewCount": 1500,
      "likeCount": 120
    }
  }
}
```

#### 3. 뉴스 검색

**엔드포인트**: `GET /api/v1/news/search`

**설명**: Full-text search를 사용하여 뉴스를 검색합니다.

**인증**: 불필요

**쿼리 파라미터**:
- `q` (String, required): 검색어
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)

**데이터 소스**: MongoDB Atlas (`NewsArticleDocument`, Full-text search)

**응답 형식**: 뉴스 목록 조회와 동일

---

## 사용자 아카이브 API 엔드포인트

**모듈**: `api-archive`

사용자가 아카이브한 항목을 관리하는 API입니다. JWT 토큰에서 userId를 추출하여 해당 사용자의 아카이브만 타게팅합니다.

**데이터베이스**: 
- **Command Side (쓰기)**: Aurora MySQL `archive` 스키마
  - `archives` 테이블: 아카이브 정보 저장
  - `archive_history` 테이블: 아카이브 변경 이력 저장
- **Query Side (읽기)**: MongoDB Atlas `ArchiveDocument`

**스키마 설정**:
- `api-archive-application.yml`에서 `module.aurora.schema=archive` 설정
- `domain/aurora/src/main/resources/application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적으로 `archive` 스키마에 연결

**중요**: 모든 쓰기 작업은 Aurora MySQL에서 수행되고, 모든 읽기 작업은 MongoDB Atlas에서 수행됩니다. 단, 삭제된 아카이브 조회는 CQRS 패턴 예외로 Aurora MySQL에서 수행됩니다.

### 아카이브 추가

**엔드포인트**: `POST /api/v1/archive`

**설명**: 새로운 아카이브를 추가합니다.

**인증**: 필요 (JWT Access Token)

**요청 Body**:
```json
{
  "itemType": "CONTEST",
  "itemId": "507f1f77bcf86cd799439012",
  "tag": "algorithm",
  "memo": "참가 예정"
}
```

**주의사항**: 요청 body의 `userId`는 무시하고, JWT 토큰에서 추출한 `userId`를 사용합니다.

**데이터 소스**: Aurora MySQL (`Archive` 엔티티)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 데이터 검증 (itemType, itemId)
3. 중복 검증 (Aurora MySQL, userId + itemType + itemId, is_deleted=FALSE)
4. `Archive` 엔티티 생성 (Aurora MySQL, userId 자동 설정)
5. `ArchiveHistory` 엔티티 생성 (operation_type: INSERT)
6. **Kafka 이벤트 발행**: `ArchiveCreatedEvent`
   - 이벤트 페이로드: `archiveTsid` (Archive.id), `userId`, `itemType`, `itemId`, `tag`, `memo` 등

**제약사항**: `userId + itemType + itemId` UNIQUE 제약조건 (중복 방지)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "archiveTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "tag": "algorithm",
    "memo": "참가 예정",
    "archivedAt": "2026-01-07T10:00:00Z"
  }
}
```

---

### 아카이브 목록 조회

**엔드포인트**: `GET /api/v1/archive`

**설명**: 로그인 사용자의 아카이브 목록을 조회합니다.

**인증**: 필요 (JWT Access Token)

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `sort` (String, optional): 정렬 기준 (기본값: "createdAt,desc")
  - 가능한 값: `createdAt,asc`, `createdAt,desc`, `archivedAt,asc`, `archivedAt,desc`
- `itemType` (String, optional): 항목 타입 필터
  - 가능한 값: `CONTEST`, `NEWS_ARTICLE`

**데이터 소스**: MongoDB Atlas (`ArchiveDocument`)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `ArchiveDocument` 조회 (MongoDB Atlas, userId 필터링)
3. 페이징 및 정렬 적용

**인덱스 활용**: `userId + createdAt` 복합 인덱스 또는 `userId + itemType + createdAt` 복합 인덱스

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "pageSize": 10,
    "pageNumber": 1,
    "totalPageNumber": 5,
    "totalSize": 50,
    "list": [
      {
        "_id": "507f1f77bcf86cd799439015",
        "archiveTsid": "1234567890123456789",
        "userId": "9876543210987654321",
        "itemType": "CONTEST",
        "itemId": "507f1f77bcf86cd799439012",
        "itemTitle": "Codeforces Round 900",
        "itemSummary": "Regular Codeforces contest",
        "tag": "algorithm",
        "memo": "참가 예정",
        "archivedAt": "2026-01-07T10:00:00Z"
      }
    ]
  }
}
```

---

### 아카이브 상세 조회

**엔드포인트**: `GET /api/v1/archive/{id}`

**설명**: 특정 아카이브의 상세 정보를 조회합니다.

**인증**: 필요 (JWT Access Token)

**경로 파라미터**:
- `id` (String, required): 아카이브 ID (MongoDB ObjectId 또는 archiveTsid)

**데이터 소스**: MongoDB Atlas (`ArchiveDocument`)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `ArchiveDocument` 조회 (MongoDB Atlas, id 또는 archiveTsid, userId 필터링)
3. 권한 검증 (본인의 아카이브만 조회 가능)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "_id": "507f1f77bcf86cd799439015",
    "archiveTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "itemTitle": "Codeforces Round 900",
    "itemSummary": "Regular Codeforces contest",
    "tag": "algorithm",
    "memo": "참가 예정",
    "archivedAt": "2026-01-07T10:00:00Z"
  }
}
```

---

### 아카이브 수정

**엔드포인트**: `PUT /api/v1/archive/{id}`

**설명**: 아카이브 정보를 수정합니다.

**인증**: 필요 (JWT Access Token)

**경로 파라미터**:
- `id` (String, required): 아카이브 ID (archiveTsid, TSID)

**요청 Body**:
```json
{
  "tag": "updated-algorithm",
  "memo": "수정된 메모"
}
```

**데이터 소스**: Aurora MySQL (`Archive` 엔티티)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `Archive` 엔티티 조회 (Aurora MySQL, id=archiveTsid, userId 검증)
3. 권한 검증 (본인의 아카이브만 수정 가능)
4. `Archive` 엔티티 업데이트 (Aurora MySQL)
5. `ArchiveHistory` 엔티티 생성 (operation_type: UPDATE)
6. **Kafka 이벤트 발행**: `ArchiveUpdatedEvent`
   - 이벤트 페이로드: `archiveTsid`, 변경된 필드 정보 포함

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "archiveTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "tag": "updated-algorithm",
    "memo": "수정된 메모",
    "archivedAt": "2026-01-07T10:00:00Z"
  }
}
```

---

### 아카이브 삭제 (Soft Delete)

**엔드포인트**: `DELETE /api/v1/archive/{id}`

**설명**: 아카이브를 삭제합니다 (Soft Delete).

**인증**: 필요 (JWT Access Token)

**경로 파라미터**:
- `id` (String, required): 아카이브 ID (archiveTsid, TSID)

**데이터 소스**: Aurora MySQL (`Archive` 엔티티)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `Archive` 엔티티 조회 (Aurora MySQL, id=archiveTsid, userId 검증)
3. 권한 검증 (본인의 아카이브만 삭제 가능)
4. `Archive` 엔티티 Soft Delete (Aurora MySQL, is_deleted=TRUE, deleted_at 설정, deleted_by=userId)
5. `ArchiveHistory` 엔티티 생성 (operation_type: DELETE)
6. **Kafka 이벤트 발행**: `ArchiveDeletedEvent`
   - 이벤트 페이로드: `archiveTsid`, `userId`, `deletedAt` 등
   - MongoDB Atlas의 `ArchiveDocument`는 물리적 삭제 (MongoDB는 Soft Delete 미지원)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": null
}
```

---

### 아카이브 복원

**엔드포인트**: `POST /api/v1/archive/{id}/restore`

**설명**: 삭제된 아카이브를 복원합니다.

**인증**: 필요 (JWT Access Token)

**경로 파라미터**:
- `id` (String, required): 아카이브 ID (archiveTsid, TSID)

**데이터 소스**: Aurora MySQL (`Archive` 엔티티)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `Archive` 엔티티 조회 (Aurora MySQL, id=archiveTsid, userId 검증, is_deleted=TRUE)
3. 권한 검증 (본인의 아카이브만 복원 가능)
4. `Archive` 엔티티 복원 (Aurora MySQL, is_deleted=FALSE, deleted_at=null, deleted_by=null)
5. `ArchiveHistory` 엔티티 생성 (operation_type: UPDATE)
6. **Kafka 이벤트 발행**: `ArchiveRestoredEvent`
   - 이벤트 페이로드: `archiveTsid`, `userId`, `itemType`, `itemId`, `tag`, `memo` 등
   - MongoDB Atlas의 `ArchiveDocument` 새로 생성 (MongoDB는 Soft Delete 미지원이므로 복원 시 재생성 필요)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "archiveTsid": "1234567890123456789",
    "userId": "9876543210987654321",
    "itemType": "CONTEST",
    "itemId": "507f1f77bcf86cd799439012",
    "tag": "algorithm",
    "memo": "참가 예정",
    "archivedAt": "2026-01-07T10:00:00Z"
  }
}
```

---

### 삭제된 아카이브 목록 조회

**엔드포인트**: `GET /api/v1/archive/deleted`

**설명**: 삭제된 아카이브 목록을 조회합니다.

**인증**: 필요 (JWT Access Token)

**주의사항**: MongoDB Atlas는 Soft Delete를 구현하지 않으므로, 삭제된 아카이브는 Aurora MySQL에서만 조회 가능합니다 (CQRS 패턴 예외).

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `sort` (String, optional): 정렬 기준 (기본값: "deletedAt,desc")
  - 가능한 값: `deletedAt,asc`, `deletedAt,desc`

**데이터 소스**: Aurora MySQL (`Archive` 엔티티, CQRS 패턴 예외)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. `Archive` 엔티티 조회 (Aurora MySQL, userId + is_deleted=TRUE 필터링)
3. 페이징 및 정렬 적용

**인덱스 활용**: `user_id + is_deleted` 복합 인덱스

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "pageSize": 10,
    "pageNumber": 1,
    "totalPageNumber": 2,
    "totalSize": 15,
    "list": [
      {
        "archiveTsid": "1234567890123456789",
        "userId": "9876543210987654321",
        "itemType": "CONTEST",
        "itemId": "507f1f77bcf86cd799439012",
        "tag": "algorithm",
        "memo": "참가 예정",
        "archivedAt": "2026-01-07T10:00:00Z",
        "deletedAt": "2026-01-08T10:00:00Z"
      }
    ]
  }
}
```

---

### 변경 이력 조회

**엔드포인트**: `GET /api/v1/archive/history/{entityId}`

**설명**: 특정 아카이브 엔티티의 변경 이력을 조회합니다. `api-archive` 모듈은 `archive` 엔티티 타입의 변경 이력을 조회합니다.

**인증**: 필요 (JWT Access Token, 관리자 또는 본인)

**경로 파라미터**:
- `entityId` (String, required): 아카이브 엔티티 ID (TSID)

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `operationType` (String, optional): 작업 타입 필터
  - 가능한 값: `INSERT`, `UPDATE`, `DELETE`
- `startDate` (String, optional): 시작 일시 (ISO 8601)
- `endDate` (String, optional): 종료 일시 (ISO 8601)

**데이터 소스**: Aurora MySQL (`ArchiveHistory` 엔티티, CQRS 패턴 예외)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자 또는 본인)
3. `ArchiveHistory` 테이블에서 히스토리 엔티티 조회 (Aurora MySQL, 필터링 및 페이징)

**인덱스 활용**: `operation_type + changed_at` 복합 인덱스

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "pageSize": 10,
    "pageNumber": 1,
    "totalPageNumber": 3,
    "totalSize": 25,
    "list": [
      {
        "historyId": "1111111111111111111",
        "entityId": "1234567890123456789",
        "operationType": "UPDATE",
        "beforeData": {
          "tag": "algorithm",
          "memo": "참가 예정"
        },
        "afterData": {
          "tag": "updated-algorithm",
          "memo": "수정된 메모"
        },
        "changedBy": "9876543210987654321",
        "changedAt": "2026-01-08T10:00:00Z",
        "changeReason": "사용자 요청"
      }
    ]
  }
}
```

---

### 특정 시점 데이터 조회

**엔드포인트**: `GET /api/v1/archive/history/{entityId}/at`

**설명**: 특정 시점의 아카이브 엔티티 데이터를 조회합니다. `api-archive` 모듈은 `archive` 엔티티 타입의 특정 시점 데이터를 조회합니다.

**인증**: 필요 (JWT Access Token, 관리자 또는 본인)

**경로 파라미터**:
- `entityId` (String, required): 아카이브 엔티티 ID (TSID)

**쿼리 파라미터**:
- `timestamp` (String, required): 시점 (ISO 8601)

**데이터 소스**: Aurora MySQL (히스토리 테이블의 `before_data`/`after_data` JSON 필드, CQRS 패턴 예외)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자 또는 본인)
3. 히스토리 테이블에서 해당 시점 이전의 가장 최근 이력 조회
4. `after_data` JSON 필드에서 데이터 추출

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "entityId": "1234567890123456789",
    "timestamp": "2026-01-08T10:00:00Z",
    "data": {
      "archiveTsid": "1234567890123456789",
      "userId": "9876543210987654321",
      "itemType": "CONTEST",
      "itemId": "507f1f77bcf86cd799439012",
      "tag": "updated-algorithm",
      "memo": "수정된 메모"
    }
  }
}
```

---

### 특정 버전으로 복구

**엔드포인트**: `POST /api/v1/archive/history/{entityId}/restore`

**설명**: 특정 히스토리 버전으로 아카이브 엔티티를 복구합니다. `api-archive` 모듈은 `archive` 엔티티 타입의 특정 버전을 복구합니다.

**인증**: 필요 (JWT Access Token, 관리자만)

**경로 파라미터**:
- `entityId` (String, required): 아카이브 엔티티 ID (TSID)

**쿼리 파라미터**:
- `historyId` (String, required): 히스토리 ID (TSID)

**데이터 소스**: Aurora MySQL (히스토리 테이블 및 엔티티 테이블)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자만)
3. 히스토리 엔티티 조회 (Aurora MySQL, historyId)
4. `after_data` JSON 필드를 기반으로 엔티티 복구 (Aurora MySQL)
5. 히스토리 엔티티 생성 (operation_type: UPDATE)
6. **Kafka 이벤트 발행**: `ArchiveUpdatedEvent`

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "message": "엔티티가 성공적으로 복구되었습니다.",
    "entityId": "1234567890123456789",
    "restoredHistoryId": "1111111111111111111"
  }
}
```

---

## 인증 API 엔드포인트

**모듈**: `api-auth`

사용자 인증 및 토큰 관리를 위한 API입니다. 모든 쓰기 작업은 Aurora MySQL에서 수행됩니다.

**데이터베이스**: 
- **Command Side (쓰기)**: Aurora MySQL `auth` 스키마
  - `providers`, `users`, `admins`, `refresh_tokens`, `email_verifications`, `user_history`, `admin_history` 테이블 관리

**스키마 설정**:
- `api-auth-application.yml`에서 `module.aurora.schema=auth` 설정
- `domain/aurora/src/main/resources/application-api-domain.yml`에서 `${module.aurora.schema}` 사용하여 동적으로 `auth` 스키마에 연결

### 회원가입

**엔드포인트**: `POST /api/v1/auth/signup`

**설명**: 새로운 사용자를 등록합니다.

**인증**: 불필요

**요청 Body**:
```json
{
  "email": "user@example.com",
  "username": "john_doe",
  "password": "securePassword123"
}
```

**데이터 소스**: Aurora MySQL (`User` 엔티티, `EmailVerification` 엔티티)

**처리 로직**:
1. 이메일 중복 검증 (Aurora MySQL, `is_deleted=FALSE` 조건 포함)
2. 사용자명 중복 검증 (Aurora MySQL, `is_deleted=FALSE` 조건 포함)
3. 비밀번호 정책 검증 (최소 8자, 대소문자/숫자/특수문자 중 2가지 이상 포함)
4. 비밀번호 해시 생성 (BCrypt 알고리즘, salt rounds: 12)
5. 트랜잭션 시작
6. `User` 엔티티 생성 (Aurora MySQL)
7. `EmailVerification` 엔티티 생성 (Aurora MySQL, `type=EMAIL_VERIFICATION`, `expires_at`: 현재 시간 + 24시간)
8. `UserHistory` 엔티티 생성 (operation_type: INSERT)
9. 트랜잭션 커밋
10. **Kafka 이벤트 발행**: `UserCreatedEvent`
11. 이메일 인증 토큰 발송 (비동기 처리, 실패 시 재시도 로직 실행)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "userId": "1234567890123456789",
    "email": "user@example.com",
    "username": "john_doe",
    "message": "회원가입이 완료되었습니다. 이메일 인증을 완료해주세요."
  }
}
```

---

### 로그인

**엔드포인트**: `POST /api/v1/auth/login`

**설명**: 사용자 로그인을 처리하고 JWT 토큰을 발급합니다.

**인증**: 불필요

**요청 Body**:
```json
{
  "email": "user@example.com",
  "password": "securePassword123"
}
```

**데이터 소스**: Aurora MySQL (`User` 엔티티, `RefreshToken` 엔티티)

**처리 로직**:
1. 이메일로 `User` 엔티티 조회 (Aurora MySQL, `is_deleted=FALSE` 조건 포함)
2. 비밀번호 검증 (BCrypt 알고리즘으로 해시된 비밀번호와 입력 비밀번호 비교)
3. 이메일 인증 여부 확인 (`is_email_verified=TRUE` 확인, `FALSE`인 경우 로그인 차단)
4. JWT Access Token 생성 (만료 시간: 3600초=1시간, 서명 알고리즘: HS256 또는 RS256)
5. JWT Refresh Token 생성 (만료 시간: 7일)
6. 트랜잭션 시작
7. `RefreshToken` 엔티티 생성 (Aurora MySQL, `expires_at`: 현재 시간 + 7일)
8. `User` 엔티티 업데이트 (`last_login_at` 필드 업데이트)
9. `UserHistory` 엔티티 생성 (operation_type: UPDATE)
10. 트랜잭션 커밋

**Rate Limiting**: 5회/분 (무차별 대입 공격 방지)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600,
    "refreshTokenExpiresIn": 604800
  }
}
```

---

### 로그아웃

**엔드포인트**: `POST /api/v1/auth/logout`

**설명**: 사용자 로그아웃을 처리하고 Refresh Token을 무효화합니다.

**인증**: 필요 (JWT Access Token)

**요청 Body**:
```json
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**데이터 소스**: Aurora MySQL (`RefreshToken` 엔티티)

**처리 로직**:
1. JWT 토큰에서 userId 추출
2. 트랜잭션 시작
3. `RefreshToken` 엔티티 조회 (Aurora MySQL, `token=요청의 refreshToken`, `is_deleted=FALSE`, `expires_at` 확인)
4. RefreshToken의 `userId`와 JWT 토큰의 `userId` 일치 여부 검증 (불일치 시 에러 반환)
5. `RefreshToken` 엔티티 Soft Delete (`is_deleted=TRUE`, `deleted_at` 설정, `deleted_by=userId`)
6. `UserHistory` 엔티티 생성 (operation_type: UPDATE)
7. 트랜잭션 커밋

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": null
}
```

---

### 토큰 갱신

**엔드포인트**: `POST /api/v1/auth/refresh`

**설명**: Refresh Token을 사용하여 새로운 Access Token을 발급합니다.

**인증**: 불필요 (Refresh Token 필요)

**요청 Body**:
```json
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**데이터 소스**: Aurora MySQL (`RefreshToken` 엔티티)

**처리 로직**:
1. Refresh Token 검증 (JWT 서명 검증)
2. `RefreshToken` 엔티티 조회 (Aurora MySQL, `token=요청의 refreshToken`, `is_deleted=FALSE`, `expires_at` 확인)
3. 새로운 Access Token 생성 (만료 시간: 3600초=1시간)
4. 트랜잭션 시작
5. 기존 `RefreshToken` 엔티티 Soft Delete (`is_deleted=TRUE`, `deleted_at` 설정)
6. 새로운 `RefreshToken` 엔티티 생성 (Aurora MySQL, `expires_at`: 현재 시간 + 7일)
7. `UserHistory` 엔티티 생성 (operation_type: UPDATE)
8. 트랜잭션 커밋

**참고**: RefreshToken 회전(Rotation) 전략 적용 - 기존 토큰 무효화 후 새 토큰 생성 (RFC 6749 베스트 프랙티스)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600
  }
}
```

---

### 이메일 인증

**엔드포인트**: `GET /api/v1/auth/verify-email`

**설명**: 이메일 인증 토큰을 검증하고 사용자 이메일을 인증합니다.

**인증**: 불필요

**쿼리 파라미터**:
- `token` (String, required): 이메일 인증 토큰

**데이터 소스**: Aurora MySQL (`EmailVerification` 엔티티, `User` 엔티티)

**처리 로직**:
1. `EmailVerification` 엔티티 조회 (Aurora MySQL, `token`, `type=EMAIL_VERIFICATION`, `is_deleted=FALSE`, `expires_at` 확인)
2. 토큰 만료 여부 확인 (`expires_at` 확인)
3. 중복 인증 방지 확인 (`verified_at`이 이미 설정되어 있는 경우 에러 반환)
4. 트랜잭션 시작
5. `EmailVerification` 엔티티 업데이트 (`verified_at` 설정, 중복 설정 방지)
6. `User` 엔티티 업데이트 (`is_email_verified` 필드를 `TRUE`로 설정)
7. `UserHistory` 엔티티 생성 (operation_type: UPDATE)
8. 트랜잭션 커밋
9. **Kafka 이벤트 발행**: `UserUpdatedEvent`

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "message": "이메일 인증이 완료되었습니다."
  }
}
```

---

### 비밀번호 재설정 요청

**엔드포인트**: `POST /api/v1/auth/reset-password`

**설명**: 비밀번호 재설정 토큰을 발급합니다.

**인증**: 불필요

**요청 Body**:
```json
{
  "email": "user@example.com"
}
```

**데이터 소스**: Aurora MySQL (`EmailVerification` 엔티티)

**처리 로직**:
1. 이메일로 `User` 엔티티 조회 (Aurora MySQL, `is_deleted=FALSE` 조건 포함)
2. 비밀번호 재설정 토큰 생성 (암호학적으로 안전한 랜덤 토큰)
3. 트랜잭션 시작
4. 동일 이메일의 기존 `PASSWORD_RESET` 타입 토큰 무효화 (Soft Delete 처리, `email + type` 복합 인덱스 활용)
5. `EmailVerification` 엔티티 생성 (Aurora MySQL, `type=PASSWORD_RESET`, `expires_at`: 현재 시간 + 24시간)
6. 트랜잭션 커밋
7. 이메일 발송 (비동기 처리, 존재하지 않는 이메일인 경우에도 성공 응답 반환 - 보안상 일반적, 실패 시 재시도 로직 실행)

**Rate Limiting**: 3회/시간 (무차별 대입 공격 방지)

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "message": "비밀번호 재설정 이메일이 발송되었습니다."
  }
}
```

---

### 비밀번호 재설정 확인

**엔드포인트**: `POST /api/v1/auth/reset-password/confirm`

**설명**: 비밀번호 재설정 토큰을 검증하고 새로운 비밀번호를 설정합니다.

**인증**: 불필요

**요청 Body**:
```json
{
  "token": "reset-token-123",
  "newPassword": "newSecurePassword123"
}
```

**데이터 소스**: Aurora MySQL (`EmailVerification` 엔티티, `User` 엔티티)

**처리 로직**:
1. `EmailVerification` 엔티티 조회 (Aurora MySQL, `token`, `type=PASSWORD_RESET`, `is_deleted=FALSE`, `expires_at` 확인)
2. 토큰 만료 여부 확인 (`expires_at` 확인)
3. 토큰 재사용 방지 확인 (`verified_at`이 이미 설정되어 있는 경우 에러 반환)
4. 비밀번호 정책 검증 (최소 8자, 대소문자/숫자/특수문자 중 2가지 이상 포함)
5. 비밀번호 재사용 방지 확인 (이전 비밀번호와 동일한지 검증, BCrypt로 해시된 비밀번호 비교)
6. 새로운 비밀번호 해시 생성 (BCrypt 알고리즘, salt rounds: 12)
7. 트랜잭션 시작
8. `User` 엔티티 업데이트 (`password` 필드 업데이트)
9. `EmailVerification` 엔티티 업데이트 (`verified_at` 설정, 중복 설정 방지)
10. `UserHistory` 엔티티 생성 (operation_type: UPDATE)
11. 트랜잭션 커밋
12. **Kafka 이벤트 발행**: `UserUpdatedEvent`

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "message": "비밀번호가 성공적으로 변경되었습니다."
  }
}
```

---

### OAuth 2.0 SNS 로그인

#### 1. OAuth 로그인 시작

**엔드포인트**: `GET /api/v1/auth/oauth2/{provider}`

**설명**: OAuth 2.0 로그인을 시작합니다.

**인증**: 불필요

**경로 파라미터**:
- `provider` (String, required): OAuth 제공자 (예: `google`, `github`)

**데이터 소스**: Aurora MySQL (`Provider` 엔티티)

**처리 로직**:
1. `Provider` 엔티티 조회 (Aurora MySQL, `name=provider`, `is_enabled=TRUE`, `is_deleted=FALSE`)
2. CSRF 방지를 위한 `state` 파라미터 생성 (암호학적으로 안전한 랜덤 토큰, 최소 32바이트 권장)
3. `state` 파라미터를 **Redis에 저장** (Provider 정보와 함께 저장, 만료 시간: 10분)
   - Key 형식: `oauth:state:{state_value}`
   - Value: Provider 이름 (예: "GOOGLE", "NAVER", "KAKAO")
   - TTL: 10분 (600초) - 자동 만료
   - 구현: `OAuthStateService.saveState(state, providerName)`
4. OAuth 인증 URL 생성 (`state` 파라미터 포함)
5. 리다이렉트

**State 파라미터 저장 방식:**
- **권장 방법: Redis 저장**
  - Stateless 아키텍처와 완벽 호환
  - 분산 환경 지원 (여러 서버 인스턴스 간 state 공유)
  - TTL 자동 만료로 관리 단순화
  - 빠른 읽기/쓰기 성능
- **구현 클래스**: 
  - `OAuthStateService` (`api/auth/src/main/java/com/ebson/shrimp/tm/demo/api/auth/oauth/OAuthStateService.java`)
  - `OAuthProvider` (`api/auth/src/main/java/com/ebson/shrimp/tm/demo/api/auth/oauth/OAuthProvider.java`)
  - `OAuthProviderContract` (`client/feign/src/main/java/.../domain/oauth/contract/OAuthProviderContract.java`)
- **상세 설계**: 
  - `docs/oauth-provider-implementation-guide.md` Section 5.3, 6.2 참조
  - `docs/oauth-feign-client-migration-analysis.md`: OpenFeign 클라이언트 구현 가이드

**참고**: `state` 파라미터는 OAuth 2.0 표준(RFC 6749 Section 10.12)에 따라 CSRF 공격 방지를 위한 필수 보안 메커니즘입니다. 콜백 시 검증하여 요청의 유효성을 확인하고, 검증 완료 후 즉시 삭제합니다.

**Rate Limiting**: 10회/분 (무차별 대입 공격 방지)

**응답**: OAuth 제공자 인증 페이지로 리다이렉트

---

#### 2. OAuth 로그인 콜백

**엔드포인트**: `GET /api/v1/auth/oauth2/{provider}/callback`

**설명**: OAuth 2.0 로그인 콜백을 처리합니다.

**인증**: 불필요

**경로 파라미터**:
- `provider` (String, required): OAuth 제공자 (예: `google`, `github`)

**쿼리 파라미터**:
- `code` (String, required): OAuth 인증 코드
- `state` (String, optional): CSRF 방지 상태 토큰 (OAuth 로그인 시작 시 생성된 값)

**데이터 소스**: 
- Redis (`oauth:state:{state_value}` - State 파라미터 저장)
- Aurora MySQL (`Provider` 엔티티, `User` 엔티티, `RefreshToken` 엔티티)

**처리 로직**:
1. `state` 파라미터 검증 (Redis에서 조회, 저장된 값과 일치 여부 확인, Provider 정보도 함께 검증, CSRF 방지)
   - Redis Key: `oauth:state:{state_value}`
   - 구현: `OAuthStateService.validateAndDeleteState(state, providerName)`
   - 검증 실패 시: `UnauthorizedException` 발생
2. 검증 완료 후 `state` 값 즉시 삭제 (일회성 사용, Replay Attack 방지)
3. `Provider` 엔티티 조회 (Aurora MySQL, `is_enabled=TRUE`, `is_deleted=FALSE`)
3. OAuth 인증 코드로 Access Token 교환 (실패 시 에러 반환)
   - 구현: `OAuthProvider.exchangeAccessToken()` → `OAuthProviderContract.exchangeAccessToken()` → OpenFeign 클라이언트
   - 상세 설계: `docs/oauth-provider-implementation-guide.md` Section 5.3 참조
4. OAuth 제공자 API로 사용자 정보 조회 (실패 시 에러 반환)
   - 구현: `OAuthProvider.getUserInfo()` → `OAuthProviderContract.getUserInfo()` → OpenFeign 클라이언트
   - 상세 설계: `docs/oauth-provider-implementation-guide.md` Section 5.3 참조
5. 트랜잭션 시작
6. `User` 엔티티 조회/생성 (Aurora MySQL, `provider_id + provider_user_id` 복합 인덱스 활용, `is_deleted=FALSE` 조건 포함)
   - 존재하지 않으면 `User` 엔티티 생성 (`password=NULL`, OAuth 사용자는 비밀번호 없음)
   - 존재하면 `User` 엔티티 업데이트
   - `UserHistory` 엔티티 생성 (operation_type: INSERT 또는 UPDATE)
7. JWT Access Token 생성 (만료 시간: 3600초=1시간)
8. JWT Refresh Token 생성 (만료 시간: 7일)
9. `RefreshToken` 엔티티 생성 (Aurora MySQL, `expires_at`: 현재 시간 + 7일)
10. 트랜잭션 커밋
11. **Kafka 이벤트 발행**: `UserCreatedEvent` 또는 `UserUpdatedEvent`

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600,
    "refreshTokenExpiresIn": 604800
  }
}
```

---

### 변경 이력 조회

**엔드포인트**: `GET /api/v1/auth/history/{entityType}/{entityId}`

**설명**: 특정 엔티티의 변경 이력을 조회합니다. `api-auth` 모듈은 `user`, `admin` 엔티티 타입의 변경 이력을 조회합니다.

**인증**: 필요 (JWT Access Token, 관리자 또는 본인)

**경로 파라미터**:
- `entityType` (String, required): 엔티티 타입
  - 가능한 값: `user`, `admin`
- `entityId` (String, required): 엔티티 ID (TSID)

**쿼리 파라미터**:
- `page` (Integer, optional): 페이지 번호 (기본값: 1)
- `size` (Integer, optional): 페이지 크기 (기본값: 10, 최대: 100)
- `operationType` (String, optional): 작업 타입 필터
  - 가능한 값: `INSERT`, `UPDATE`, `DELETE`
- `startDate` (String, optional): 시작 일시 (ISO 8601)
- `endDate` (String, optional): 종료 일시 (ISO 8601)

**데이터 소스**: Aurora MySQL (`UserHistory`, `AdminHistory` 엔티티, CQRS 패턴 예외)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자 또는 본인)
3. 엔티티 타입에 따라 히스토리 테이블 선택:
   - `user`: `UserHistory` 테이블
   - `admin`: `AdminHistory` 테이블
4. 히스토리 엔티티 조회 (Aurora MySQL, 필터링 및 페이징)

**인덱스 활용**: `operation_type + changed_at` 복합 인덱스

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "pageSize": 10,
    "pageNumber": 1,
    "totalPageNumber": 3,
    "totalSize": 25,
    "list": [
      {
        "historyId": "1111111111111111111",
        "entityId": "1234567890123456789",
        "operationType": "UPDATE",
        "beforeData": {
          "username": "john_doe",
          "email": "user@example.com"
        },
        "afterData": {
          "username": "john_doe_updated",
          "email": "user@example.com"
        },
        "changedBy": "9876543210987654321",
        "changedAt": "2026-01-08T10:00:00Z",
        "changeReason": "사용자 요청"
      }
    ]
  }
}
```

---

### 특정 시점 데이터 조회

**엔드포인트**: `GET /api/v1/auth/history/{entityType}/{entityId}/at`

**설명**: 특정 시점의 엔티티 데이터를 조회합니다. `api-auth` 모듈은 `user`, `admin` 엔티티 타입의 특정 시점 데이터를 조회합니다.

**인증**: 필요 (JWT Access Token, 관리자 또는 본인)

**경로 파라미터**:
- `entityType` (String, required): 엔티티 타입
  - 가능한 값: `user`, `admin`
- `entityId` (String, required): 엔티티 ID (TSID)

**쿼리 파라미터**:
- `timestamp` (String, required): 시점 (ISO 8601)

**데이터 소스**: Aurora MySQL (히스토리 테이블의 `before_data`/`after_data` JSON 필드, CQRS 패턴 예외)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자 또는 본인)
3. 히스토리 테이블에서 해당 시점 이전의 가장 최근 이력 조회
4. `after_data` JSON 필드에서 데이터 추출

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "entityId": "1234567890123456789",
    "timestamp": "2026-01-08T10:00:00Z",
    "data": {
      "userTsid": "1234567890123456789",
      "userId": "9876543210987654321",
      "username": "john_doe",
      "email": "user@example.com"
    }
  }
}
```

---

### 특정 버전으로 복구

**엔드포인트**: `POST /api/v1/auth/history/{entityType}/{entityId}/restore`

**설명**: 특정 히스토리 버전으로 엔티티를 복구합니다. `api-auth` 모듈은 `user`, `admin` 엔티티 타입의 특정 버전을 복구합니다.

**인증**: 필요 (JWT Access Token, 관리자만)

**경로 파라미터**:
- `entityType` (String, required): 엔티티 타입
  - 가능한 값: `user`, `admin`
- `entityId` (String, required): 엔티티 ID (TSID)

**쿼리 파라미터**:
- `historyId` (String, required): 히스토리 ID (TSID)

**데이터 소스**: Aurora MySQL (히스토리 테이블 및 엔티티 테이블)

**처리 로직**:
1. JWT 토큰에서 `userId` 추출
2. 권한 검증 (관리자만)
3. 히스토리 엔티티 조회 (Aurora MySQL, historyId)
4. `after_data` JSON 필드를 기반으로 엔티티 복구 (Aurora MySQL)
5. 히스토리 엔티티 생성 (operation_type: UPDATE)
6. **Kafka 이벤트 발행**: 엔티티 타입에 따라 해당 이벤트 발행
   - `user`: `UserUpdatedEvent`
   - `admin`: `AdminUpdatedEvent`

**응답 예시**:
```json
{
  "code": "2000",
  "messageCode": {
    "code": "SUCCESS",
    "text": "성공"
  },
  "message": "success",
  "data": {
    "message": "엔티티가 성공적으로 복구되었습니다.",
    "entityId": "1234567890123456789",
    "restoredHistoryId": "1111111111111111111"
  }
}
```

---

## CQRS 패턴 적용

### 읽기/쓰기 분리 원칙

| 작업 유형 | 데이터 소스 | 예외 사항 |
|-----------|------------|----------|
| 읽기 작업 | MongoDB Atlas (Query Side) | 변경 이력 조회, 삭제된 아카이브 조회는 Aurora MySQL |
| 쓰기 작업 | Aurora MySQL (Command Side) | 없음 |

### 읽기 작업 (MongoDB Atlas)

- 대회 목록/상세/검색
- 뉴스 목록/상세/검색
- 출처 목록 조회
- 아카이브 목록/상세 조회 (활성 아카이브만)

### 쓰기 작업 (Aurora MySQL)

- 회원가입, 로그인, 로그아웃, 토큰 갱신
- 이메일 인증, 비밀번호 재설정
- OAuth 2.0 로그인
- 아카이브 생성, 수정, 삭제, 복원

### 예외 사항 (Aurora MySQL 조회)

- 변경 이력 조회: 
  - `GET /api/v1/auth/history/{entityType}/{entityId}` (user, admin)
  - `GET /api/v1/archive/history/{entityId}` (archive)
- 특정 시점 데이터 조회: 
  - `GET /api/v1/auth/history/{entityType}/{entityId}/at` (user, admin)
  - `GET /api/v1/archive/history/{entityId}/at` (archive)
- 특정 버전으로 복구:
  - `POST /api/v1/auth/history/{entityType}/{entityId}/restore` (user, admin)
  - `POST /api/v1/archive/history/{entityId}/restore` (archive)
- 삭제된 아카이브 목록 조회: `GET /api/v1/archive/deleted`

---

## Kafka 이벤트 발행 전략

### 이벤트 발행 규칙

모든 쓰기 작업 후 반드시 Kafka 이벤트를 발행하여 Command Side와 Query Side 간의 데이터 일관성을 보장합니다.

### 이벤트 목록

#### User 관련 이벤트

1. **UserCreatedEvent**
   - 발행 시점: `User` 엔티티 생성 시
   - 페이로드: `userTsid` (User.id), `userId`, `username`, `email`, `profileImageUrl` 등
   - 동기화 대상: MongoDB Atlas `UserProfileDocument` 생성

2. **UserUpdatedEvent**
   - 발행 시점: `User` 엔티티 수정 시
   - 페이로드: `userTsid`, 변경된 필드 정보 포함
   - 동기화 대상: MongoDB Atlas `UserProfileDocument` 업데이트

3. **UserDeletedEvent**
   - 발행 시점: `User` 엔티티 Soft Delete 시
   - 페이로드: `userTsid`, `userId`, `deletedAt` 등
   - 동기화 대상: MongoDB Atlas `UserProfileDocument` 물리적 삭제

4. **UserRestoredEvent**
   - 발행 시점: `User` 엔티티 복원 시
   - 페이로드: `userTsid`, `userId`, `username`, `email`, `profileImageUrl` 등
   - 동기화 대상: MongoDB Atlas `UserProfileDocument` 새로 생성

#### Archive 관련 이벤트

1. **ArchiveCreatedEvent**
   - 발행 시점: `Archive` 엔티티 생성 시
   - 페이로드: `archiveTsid` (Archive.id), `userId`, `itemType`, `itemId`, `tag`, `memo` 등
   - 동기화 대상: MongoDB Atlas `ArchiveDocument` 생성

2. **ArchiveUpdatedEvent**
   - 발행 시점: `Archive` 엔티티 수정 시
   - 페이로드: `archiveTsid`, 변경된 필드 정보 포함
   - 동기화 대상: MongoDB Atlas `ArchiveDocument` 업데이트

3. **ArchiveDeletedEvent**
   - 발행 시점: `Archive` 엔티티 Soft Delete 시
   - 페이로드: `archiveTsid`, `userId`, `deletedAt` 등
   - 동기화 대상: MongoDB Atlas `ArchiveDocument` 물리적 삭제

4. **ArchiveRestoredEvent**
   - 발행 시점: `Archive` 엔티티 복원 시
   - 페이로드: `archiveTsid`, `userId`, `itemType`, `itemId`, `tag`, `memo` 등
   - 동기화 대상: MongoDB Atlas `ArchiveDocument` 새로 생성

### 이벤트 발행 순서

1. Aurora MySQL 트랜잭션 커밋
2. Kafka 이벤트 발행 (트랜잭션 아웃박스 패턴 고려)
3. MongoDB Atlas 동기화 (이벤트 수신 후)

### 동기화 지연 시간

- 목표: 1초 이내
- TSID 필드 기반 1:1 매핑으로 동기화 정확성 보장
  - `User.id(TSID)` → `UserProfileDocument.userTsid`
  - `Archive.id(TSID)` → `ArchiveDocument.archiveTsid`

---

## 결론

이 설계서는 CQRS 패턴을 기반으로 한 RESTful API 엔드포인트 설계를 제공합니다. 모든 읽기 작업은 MongoDB Atlas에서, 모든 쓰기 작업은 Aurora MySQL에서 수행되며, Kafka 이벤트를 통한 실시간 동기화가 보장됩니다.

### 주요 특징

1. ✅ **RESTful 원칙 준수**: HTTP 메서드와 상태 코드 적절히 사용
2. ✅ **CQRS 패턴 적용**: 읽기/쓰기 엔드포인트 명확히 분리
3. ✅ **JWT 기반 인증**: 사용자별 데이터 타게팅
4. ✅ **이벤트 기반 동기화**: 모든 쓰기 작업 후 Kafka 이벤트 발행
5. ✅ **Soft Delete 지원**: Aurora MySQL에서 Soft Delete 구현

### 다음 단계

1. API 컨트롤러 구현
2. 서비스 레이어 구현
3. Kafka 이벤트 발행 로직 구현
4. MongoDB Atlas 동기화 컨슈머 구현
5. JWT 토큰 인증/인가 로직 구현

---

**문서 버전**: 1.0  
**최종 업데이트**: 2026-01-07  
**작성자**: API Architect

