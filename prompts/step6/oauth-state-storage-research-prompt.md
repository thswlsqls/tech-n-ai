# OAuth 2.0 State 파라미터 저장 방법 연구 프롬프트

## 연구 목표

OAuth 2.0 Authorization Code Flow에서 CSRF 공격 방지를 위한 `state` 파라미터를 서버에 저장하는 **가장 적합한 방법**을 탐색하고 권장 사항을 제시합니다.

## 프로젝트 컨텍스트

### 기술 스택
- **프레임워크**: Spring Boot 6.x
- **인증 방식**: Stateless JWT 토큰 기반 인증
- **세션 정책**: `SessionCreationPolicy.STATELESS` (세션 미사용)
- **사용 가능한 저장소**:
  - Redis (spring-boot-starter-data-redis 의존성 포함)
  - 데이터베이스 (Aurora MySQL)
  - 인메모리 저장소

### OAuth 2.0 구현 현황
- **Flow 타입**: Authorization Code Flow
- **State 파라미터 요구사항**:
  - 생성: 암호학적으로 안전한 랜덤 값 (최소 32바이트)
  - 저장: Provider 정보와 함께 저장 필요
  - 만료 시간: 10분 권장
  - 검증: 콜백 시 일치 여부 확인 후 즉시 삭제 (일회성 사용)
  - 보안: HTTPS 전송 필수

## 연구 범위 및 제약 조건

### 필수 요구사항
1. **Stateless 아키텍처 준수**: 현재 프로젝트는 Stateless 인증 방식을 사용하므로, 세션 기반 저장은 제외
2. **공식 문서 기반**: OAuth 2.0 표준 문서(RFC 6749) 및 Spring Security 공식 문서만 참고
3. **실용성 우선**: 프로덕션 환경에서 검증된 방법만 제시
4. **오버엔지니어링 지양**: 요구사항을 충족하는 가장 단순하고 효율적인 방법 우선

### 제외 사항
- 세션 기반 저장 (Stateless 아키텍처와 상충)
- 과도한 복잡성을 도입하는 방법
- 공식 문서에 근거하지 않은 방법론

## 연구 질문

다음 질문에 대해 **공식 문서를 기반으로** 답변하세요:

1. **Redis 저장 방식**
   - Redis를 사용한 state 저장이 OAuth 2.0 표준 및 Spring Security 권장 사항과 일치하는가?
   - Redis 저장 시 고려해야 할 보안 사항은 무엇인가?
   - TTL(Time To Live) 설정의 적절한 값은 무엇인가?

2. **데이터베이스 저장 방식**
   - 데이터베이스에 state를 저장하는 것이 적절한가?
   - 만약 적절하다면, 어떤 테이블 구조와 인덱스가 필요한가?
   - 성능 및 확장성 측면에서 고려사항은 무엇인가?

3. **인메모리 저장 방식**
   - 인메모리 저장(예: ConcurrentHashMap)이 프로덕션 환경에서 적절한가?
   - 분산 환경(여러 서버 인스턴스)에서의 한계는 무엇인가?

4. **비교 및 권장 사항**
   - 각 방법의 장단점을 비교하세요
   - 현재 프로젝트 컨텍스트(Stateless, Redis 사용 가능)에서 가장 적합한 방법은 무엇인가?
   - 선택한 방법의 구현 가이드를 제시하세요

## 참고 자료 (공식 문서만 사용)

### 필수 참고 문서
1. **RFC 6749** (OAuth 2.0 Authorization Framework)
   - Section 10.12: CSRF Protection
   - Section 4.1.1: Authorization Request
   - Section 4.1.2: Authorization Response

2. **Spring Security 공식 문서**
   - OAuth 2.0 Client 공식 문서
   - Spring Session Data Redis 공식 문서 (Redis 사용 시)

3. **Redis 공식 문서** (Redis 사용 시)
   - Redis Security Best Practices
   - Redis TTL 및 Expiration 정책

### 참고 금지
- 블로그 포스트, 개인 의견, 비공식 튜토리얼
- 공식 문서에 근거하지 않은 방법론

## 출력 형식

다음 형식으로 결과를 제시하세요:

### 1. 방법론 비교

| 방법 | 장점 | 단점 | Stateless 호환성 | 프로덕션 적합성 |
|------|------|------|------------------|-----------------|
| Redis | ... | ... | ✅ | ✅ |
| 데이터베이스 | ... | ... | ✅ | ⚠️ |
| 인메모리 | ... | ... | ✅ | ❌ |

### 2. 권장 방법

**선택된 방법**: [방법명]

**선택 이유**:
- [이유 1]
- [이유 2]
- [이유 3]

**공식 문서 근거**:
- [RFC 6749 Section X.X 참조]
- [Spring Security 문서 참조]

### 3. 구현 가이드

**필수 구현 사항**:
1. [구현 사항 1]
2. [구현 사항 2]
3. [구현 사항 3]

**보안 고려사항**:
- [고려사항 1]
- [고려사항 2]

**코드 예시** (간결하게, 핵심 로직만):
```java
// [간결한 구현 예시]
```

### 4. 대안 방법 (선택적)

만약 권장 방법 외에 대안이 있다면, 언제 사용해야 하는지 명시하세요.

## 검증 기준

제시된 방법은 다음 기준을 만족해야 합니다:

1. ✅ **OAuth 2.0 표준 준수**: RFC 6749 요구사항 충족
2. ✅ **Stateless 아키텍처 호환**: 세션 의존성 없음
3. ✅ **보안성**: CSRF 공격 방지 효과
4. ✅ **실용성**: 프로덕션 환경 적용 가능
5. ✅ **단순성**: 오버엔지니어링 없이 요구사항 충족

## 주의사항

- **공식 문서만 참고**: 추측이나 개인 의견 배제
- **프로젝트 컨텍스트 준수**: Stateless 아키텍처와 Redis 사용 가능 여부 고려
- **실용성 우선**: 이론적 완벽함보다 실용적 해결책 제시
- **간결성**: 불필요한 복잡성 도입 지양

---

**작성일**: 2025-01-27  
**프롬프트 버전**: 1.0  
**대상**: OAuth 2.0 State 파라미터 저장 방법 연구
